<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FLITl的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些感想，一些技术，一些生活。">
<meta property="og:type" content="website">
<meta property="og:title" content="FLITl的博客">
<meta property="og:url" content="http://jackfrued.top/page/2/index.html">
<meta property="og:site_name" content="FLITl的博客">
<meta property="og:description" content="一些感想，一些技术，一些生活。">
<meta property="og:locale">
<meta property="article:author" content="FLITl">
<meta property="article:tag" content="反思，技术，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FLITl的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FLITl的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天命之谓性；率性之谓道；修道之谓教。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jackfrued.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.20.Dijkstra算法/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.20.Dijkstra%E7%AE%97%E6%B3%95/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.190Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-20-Dijkstra算法"><a href="#7-20-Dijkstra算法" class="headerlink" title="7%%  %%.20.Dijkstra算法"></a>7%%  %%.20.Dijkstra算法</h2><p>我们将用于确定最短路径的算法称为“Dijkstra算法”。Dijkstra算法是一种迭代算法，它为我们提供从一个特定起始节点到图中所有其他节点的最短路径。这也类似于广度优先搜索的结果。</p>
<p>为了跟踪从开始节点到每个目的地的总成本，我们将使用顶点类中的 dist 实例变量。 dist实例变量将包含从开始到所讨论的顶点的最小权重路径的当前总权重。该算法对图中的每个顶点重复一次;然而，我们在顶点上迭代的顺序由优先级队列控制。用于确定优先级队列中对象顺序的值为dist。当首次创建顶点时，dist被设置为非常大的数。理论上，你将 dist 设置为无穷大，但在实践中，我们只是将它设置为一个数字，大于任何真正的距离，我们将在问题中试图解决。</p>
<p>Dijkstra算法的代码如 Listing 1 所示。当算法完成时，距离设置正确，如图中每个顶点的前导链接一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> PriorityQueue, Graph, Vertex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">aGraph,start</span>):</span><br><span class="line">    pq = PriorityQueue()</span><br><span class="line">    start.setDistance(<span class="number">0</span>)</span><br><span class="line">    pq.buildHeap([(v.getDistance(),v) <span class="keyword">for</span> v <span class="keyword">in</span> aGraph])</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.isEmpty():</span><br><span class="line">        currentVert = pq.delMin()</span><br><span class="line">        <span class="keyword">for</span> nextVert <span class="keyword">in</span> currentVert.getConnections():</span><br><span class="line">            newDist = currentVert.getDistance() \</span><br><span class="line">                    + currentVert.getWeight(nextVert)</span><br><span class="line">            <span class="keyword">if</span> newDist &lt; nextVert.getDistance():</span><br><span class="line">                nextVert.setDistance( newDist )%% %% %%  %% %% %%</span><br><span class="line">                nextVert.setPred(currentVert)</span><br><span class="line">                pq.decreaseKey(nextVert,newDist)</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>Dijkstra的算法使用优先级队列。你可能还记得，优先级队列是基于我们在树章节中实现的堆。这个简单的实现和我们用于Dijkstra算法的实现之间有几个区别。首先，PriorityQueue 类存储键值对的元组。这对于Dijkstra的算法很重要，因为优先级队列中的键必须匹配图中顶点的键。其次，值用于确定优先级，并且用于确定键在优先级队列中的位置。在这个实现中，我们使用到顶点的距离作为优先级，因为我们看到当探索下一个顶点时，我们总是要探索具有最小距离的顶点。第二个区别是增加 <code>decreaseKey</code> 方法。正如你看到的，当一个已经在队列中的顶点的距离减小时，使用这个方法，将该顶点移动到队列的前面。</p>
<p>让我们使用下面的序列图像作为指导，一次应用 Dijkstra 算法的一个顶点。我们从顶点 u 开始。与 u 相邻的三个顶点是 v，w 和 x。由于到 v，w 和 x 的初始距离都被初始化为 <code>sys.maxint</code>，通过起始节点获得它们的新成本都是它们的直接成本。因此，我们将这三个节点中的每一个成本更新。我们还将每个节点的前导设置为 u，并将每个节点添加到优先级队列。我们使用距离作为优先级队列的键。算法的状态如 Figure 3所示。</p>
<p>在 while 循环的下一次迭代中，我们检查与 x 相邻的顶点。顶点 x 是下一个，因为它具有最低的总成本，因此冒泡到优先级队列的开始。在 x，我们看看它的邻居 u，v，w 和 y。对于每个相邻顶点，我们检查通过 x 到该顶点的距离是否小于先前已知的距离。显然，这是 y 的情况，因为它的距离是 sys.maxint。这不是 u 或 v 的情况，因为它们的距离分别为 0 和 2。然而，我们现在知道，如果我们经过 x 而不是从 u 直接到 w，到 w 的距离更小。既然是这样，我们用新的距离更新 w，并将 w 的前导从 u 更改为 x。有关所有顶点的状态，请参见 Figure 4。</p>
<p>下一步是查看邻近 v 的顶点（参见 Figure 5）。此步骤不会对图形进行任何更改，因此我们继续前进到节点 y。在节点 y（见Figure 6），我们发现到 w 和 z 都更小，因此我们相应地调整距离和前导链接。最后，我们检查节点 w 和 z（参见 Figure 6 和 Figure 8）。但是，没有发现额外的更改，因此优先级队列为空，Dijkstra的算法退出。</p>
<p><img src="/assets/7.20.Dijkstra%E7%AE%97%E6%B3%95.figure3.png" alt="7.20.Dijkstra算法.figure3"></p>
<p><img src="/assets/7.20.Dijkstra%E7%AE%97%E6%B3%95.figure4.png" alt="7.20.Dijkstra算法.figure4"></p>
<p><img src="/assets/7.20.Dijkstra%E7%AE%97%E6%B3%95.figure5.png" alt="7.20.Dijkstra算法.figure5"></p>
<p>重要的是要注意，Dijkstra的算法只有当权重都是正数时才起作用。 如果你在图的边引入一个负权重，算法永远不会退出。</p>
<p>我们将注意到，通过因特网路由发送消息，可以使用其他算法来找到最短路径。 在互联网上使用 Dijkstra 算法的一个问题是，为了使算法运行，你必须有一个完整的图表示。 这意味着每个路由器都有一个完整的互联网中所有路由器地图。 实际上不是这种情况，算法的其他变种允许每个路由器在它们发送时发现图。 你可能想要了解的一种这样的算法称为 “距离矢量” 路由算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.20.Dijkstra%E7%AE%97%E6%B3%95/README/" data-id="clxzhp6k700321s8j3bxrgoz8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.2.词汇和定义/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.2.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.183Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-2-词汇和定义"><a href="#7-2-词汇和定义" class="headerlink" title="7.2.词汇和定义"></a>7.2.词汇和定义</h2><p>现在我们已经看了一些图的示例，我们将更正式地定义图及其组件。我们已经从对树的讨论中知道了一些术语。</p>
<p><strong>顶点</strong><br>顶点（也称为“节点”）是图的基本部分。它可以有一个名称，我们将称为“键”。一个顶点也可能有额外的信息。我们将这个附加信息称为“有效载荷”。</p>
<p><strong>边</strong><br>边（也称为“弧”）是图的另一个基本部分。边连接两个顶点，以表明它们之间存在关系。边可以是单向的或双向的。如果图中的边都是单向的，我们称该图是<code>有向图</code>。上面显示的课程先决条件显然是一个图，因为你必须在其他课程之前学习一些课程。</p>
<p><strong>权重</strong><br>边可以被加权以示出从一个顶点到另一个顶点的成本。例如，在将一个城市连接到另一个城市的道路的图表中，边上的权重可以表示两个城市之间的距离。</p>
<p>利用这些定义，我们可以正式定义图。图可以由 G 表示，其中 $$G &#x3D;(V,E)$$。对于图 G，V 是一组顶点，E 是一组边。每个边是一个元组 $$(v,w)$$，其中 $$w,v \in V$$。我们可以添加第三个组件到边元组来表示权重。子图 s 是边 e 和顶点 v 的集合，使得 $$e \subset E$$ 和 $$v \subset V$$ 。</p>
<p>Figure 2 展示了简单加权有向图的另一示例。正式地，我们可以将该图表示为六个顶点的集合：</p>
<p>$$<br>V &#x3D; \left{ V0,V1,V2,V3,V4,V5 \right}<br>$$</p>
<p>和 9 条边的集合</p>
<p>$$<br>\begin{aligned}<br>E &#x3D; \left{<br>    \begin{array}<br>        {l}(v0,v1,5), (v1,v2,4), (v2,v3,9), (v3,v4,7), (v4,v0,1), \<br>        (v0,v5,2),(v5,v4,8),(v3,v5,3),(v5,v2,1)<br>    \end{array}<br>    \right}<br>\end{aligned}<br>$$</p>
<p><img src="/assets/7.2.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89.figure2.png" alt="7.2.词汇和定义.figure2"><br><em>Figure 2</em></p>
<p>figure 2 中的示例图有助于说明两个其他关键图形术语：</p>
<p><strong>路径</strong><br>图中的路径是由边连接的顶点序列。形式上，我们将定义一个路径为 $$w_1, w_2, …, w_n$$，使得$$(w_i, w_{i+1}) \in E$$, 当 $$1  \leq i  \leq n-1$$。未加权路径长度是路径中的边的数目，具体是 $$n-1$$ 。加权路径长度是路径中所有边的权重的总和。例如在 Figure 2中，从 V3 到 V1 的路径是顶点序列 $$(V3,V4,V0,V1)$$。边是 $${(v3,v4,7),(v4,v0,1),(v0,v1,5)}$$。</p>
<p><strong>循环</strong><br>有向图中的循环是在同一顶点开始和结束的路径。例如，在 Figure 2中，路径$$(V5,V2,V3,V5)$$是一个循环。没有循环的图形称为非循环图形。没有循环的有向图称为有向无环图或 <code>DAG</code> 。我们将看到，如果问题可以表示为 <code>DAG</code>，我们可以解决几个重要的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.2.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89/README/" data-id="clxzhp6k6002v1s8jb5ze5vr3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.19.最短路径问题/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.19.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.174Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-19-最短路径问题"><a href="#7-19-最短路径问题" class="headerlink" title="7.19.最短路径问题"></a>7.19.最短路径问题</h2><p>当你在网上冲浪，发送电子邮件，或从校园的另一个地方登录实验室计算机时，大量的工作正在幕后进行，以获取你计算机上的信息传输到另一台计算机。 深入研究信息如何通过互联网从一台计算机流向另一台计算机是计算机网络中的一个主要课题。 然而，我们将讨论互联网如何工作足以理解另一个非常重要的图算法。</p>
<p><img src="/assets/7.19.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.figure1.png" alt="7.19.最短路径问题.figure1"></p>
<p><em>Figure 1</em></p>
<p>Figure 1 展示了 Internet 上的通信如何工作的高层概述。当使用浏览器从服务器请求网页时，请求必须通过局域网传输，并通过路由器传输到 Internet上。 该请求通过因特网传播，并最终到达服务器所在的局域网路由器。 请求的网页然后通过相同的路由器回到您的浏览器。 在 Figure 1中标记为 “因特网” 的云是附加的路由器。所有这些路由器一起工作，让信息从一个地方到另一个地方。 可以看到有许多路由器，如果你的计算机支持 <code>traceroute</code> 命令。下面的文本显示 <code>traceroute</code> 命令的输出，说明在 <code>Luther College</code> 的Web服务器和明尼苏达大学的邮件服务器之间有13个路由器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1  192.203.196.1</span><br><span class="line">2  hilda.luther.edu (216.159.75.1)</span><br><span class="line">3  ICN-Luther-Ether.icn.state.ia.us (207.165.237.137)</span><br><span class="line">4  ICN-ISP-1.icn.state.ia.us (209.56.255.1)</span><br><span class="line">5  p3-0.hsa1.chi1.bbnplanet.net (4.24.202.13)</span><br><span class="line">6  ae-1-54.bbr2.Chicago1.Level3.net (4.68.101.97)</span><br><span class="line">7  so-3-0-0.mpls2.Minneapolis1.Level3.net (64.159.4.214)</span><br><span class="line">8  ge-3-0.hsa2.Minneapolis1.Level3.net (4.68.112.18)</span><br><span class="line">9  p1-0.minnesota.bbnplanet.net (4.24.226.74)</span><br><span class="line">10  TelecomB-BR-01-V4002.ggnet.umn.edu (192.42.152.37)</span><br><span class="line">11  TelecomB-BN-01-Vlan-3000.ggnet.umn.edu (128.101.58.1)</span><br><span class="line">12  TelecomB-CN-01-Vlan-710.ggnet.umn.edu (128.101.80.158)</span><br><span class="line">13  baldrick.cs.umn.edu (128.101.80.129)(N!)  88.631 ms (N!)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Routers from One Host to the Next over the Internet</span><br></pre></td></tr></table></figure>

<p>互联网上的每个路由器都连接到一个或多个路由器。因此，如果在一天的不同时间运行 traceroute 命令，你很可能会看到你的信息在不同的时间流经不同的路由器。这是因为存在与一对路由器之间的每个连接相关联的成本，这取决于业务量，一天中的时间以及许多其他因素。到这个时候，你不会惊讶，我们可以将路由器的网络表示为带有加权边的图形。</p>
<p><img src="/assets/7.19.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.figure2.png" alt="7.19.最短路径问题.figure2"></p>
<p><em>Figure 2</em></p>
<p>Figure 2 展示了表示互联网中的路由器的互连的加权图的一个小例子。我们要解决的问题是找到具有最小总权重的路径，沿着该路径路由传送任何给定的消息。这个问题听起来很熟悉，因为它类似于我们使用广度优先搜索解决的问题，我们这里关心的是路径的总权重，而不是路径中的跳数。应当注意，如果所有权重相等，则问题是相同的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.19.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/README/" data-id="clxzhp6k5002u1s8j54eu4ref" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.18.强连通分量/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.156Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-18-强连通分量"><a href="#7-18-强连通分量" class="headerlink" title="7.18.强连通分量"></a>7.18.强连通分量</h2><p>在本章的剩余部分，我们将把注意力转向一些非常大的图。我们将用来研究一些附加算法的图，由互联网上的主机之间的连接和网页之间的链接产生的图。 我们将从网页开始。</p>
<p>像 Google 和 Bing 这样的搜索引擎利用了网页上的页面形成非常大的有向图。 为了将万维网变换为图，我们将把一个页面视为一个顶点，并将页面上的超链接作为将一个顶点连接到另一个顶点的边缘。 Figure 30 展示了从 Luther College 的计算机科学主页开始，通过跟踪从一页到下一页的链接产生的图的非常小的部分。当然，这个图可能是巨大的，所以我们把它限制在距离 CS 主页不超过 10 个链接的网站。</p>
<p><img src="/assets/7.18.%E5%BC%BA%E8%BF%9E%E6%8E%A5%E7%BB%84%E4%BB%B6.figure30.png" alt="7.18.强连接组件.figure30"></p>
<p><em>Figure 30</em></p>
<p>如果你看 Figure 30中的图形，你可能会有一些有趣的观察。首先你可能会注意到，图上的许多其他网站是其他路德学院网站。第二，你可能注意到有几个链接到爱荷华州的其他学院。第三，你可能注意到有几个链接到其他文理学院。你可能会得出这样的结论，网络集群上的网站在一些级别上底层结构类似。</p>
<p>可以帮助找到图中高度互连的顶点的集群的一种图算法被称为强连通分量算法（SCC）。我们正式定义图 G 的强连通分量 C 作为顶点 $$C \subset V$$ 的最大子集，使得对于每对顶点 $$v,w \in C$$，我们具有从 v 到 w 的路径和从 w 到 v 的路径。Figure 27 展示了具有三个强连接分量的简单图。强连接分量由不同的阴影区域标识。</p>
<p><img src="/assets/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.figure27.png" alt="7.18.强连通分量.figure27"></p>
<p><em>Figure 27</em></p>
<p>一旦确定了强连通分量，我们就可以通过将一个强连通分量中的所有顶点组合成一个较大的顶点来显示该图的简化视图。 Figure 31中的曲线图的简化版本如 Figure 32所示。</p>
<p><img src="/assets/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.figure31.png" alt="7.18.强连通分量.figure31"></p>
<p><em>Figure 32</em></p>
<p>我们再次看到，我们可以通过使用深度优先搜索来创建一个非常强大和高效的算法。 在我们处理主 SCC 算法之前，我们必须考虑另一个定义。 图 G 的转置被定义为图 $$G^T$$ ，其中图中的所有边已经反转。 也就是说，如果在原始图中存在从节点 A 到节点 B 的有向边，则 $$G^T$$ 将包含从节点 B 到节点 A 的边。Figure 33和 Figure 34 展示了简单图及其变换。</p>
<p><img src="/assets/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.figure32.png" alt="7.18.强连通分量.figure32"></p>
<p><em>Figure 33-34</em></p>
<p>再看看数字。 请注意，Figure 33中的图形有两个强连通分量。 现在看看Figure 34。注意它也有两个强连通分量。</p>
<p>我们现在可以描述用于计算图的强连通分量的算法。</p>
<ol>
<li>调用 dfs 为图 G 计算每个顶点的完成时间。</li>
<li>计算 $$G^T$$ 。</li>
<li>为图 $$G^T$$ 调用 dfs，但在 DFS 的主循环中，以完成时间的递减顺序探查每个顶点。</li>
<li>在步骤 3 中计算的森林中的每个树是强连通分量。输出森林中每个树中每个顶点的顶点标识组件。</li>
</ol>
<p>让我们在 Figure 31中的示例图上跟踪上述步骤的操作。Figure 35 展示了由 DFS 算法为原始图计算的开始和结束时间。 Figure 36 展示了通过在转置图上运行 DFS 计算的开始和结束时间。</p>
<p><img src="/assets/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.figure35-36.png" alt="7.18.强连通分量.figure35-36"></p>
<p><em>Figure 36</em></p>
<p>最后，Figure 37 展示了在强连通分量算法的步骤 3 中产生的三棵树的森林。 你会注意到，我们不为你提供 SCC 算法的 Python 代码，我们将此程序作为练习。</p>
<p><img src="/assets/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.figure37.png" alt="7.18.强连通分量.figure37"></p>
<p><em>Figure 37</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.18.%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/README/" data-id="clxzhp6k5002r1s8jfzdbd114" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.17.拓扑排序/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.17.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.144Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-17-拓扑排序"><a href="#7-17-拓扑排序" class="headerlink" title="7.17.拓扑排序"></a>7.17.拓扑排序</h2><p>为了表明计算机科学家可以把任何东西变成一个图问题，让我们考虑做一批煎饼的问题。 菜谱真的很简单：1个鸡蛋，1杯煎饼粉，1汤匙油 和 3&#x2F;4 杯牛奶。 要制作煎饼，你必须加热炉子，将所有的成分混合在一起，勺子搅拌。 当开始冒泡，你把它们翻过来，直到他们底部变金黄色。 在你吃煎饼之前，你会想要加热一些糖浆。 Figure 27将该过程示为图。</p>
<p><img src="/assets/7.17.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.figure27.png" alt="7.17.拓扑排序.figure27"></p>
<p><em>Figure 27</em></p>
<p>制作煎饼的困难是知道先做什么。从 Figure 27 可以看出，你可以从加热煎饼开始，或通过添加任何成分到煎饼。为了帮助我们决定应该做的每一个步骤的精确顺序，我们转向一个图算法称为 <code>拓扑排序</code>。</p>
<p>拓扑排序采用有向无环图，并且产生所有其顶点的线性排序，使得如果图 G 包含边$$(v,w)$$，则顶点 v 在排序中位于顶点 w 之前。定向非循环图在许多应用中使用以指示事件的优先级。制作煎饼只是一个例子;其他示例包括软件项目计划，用于数据库查询的优先图以及乘法矩阵。</p>
<p>拓扑排序是深度优先搜索的简单但有用的改造。拓扑排序的算法如下：</p>
<ol>
<li>对于某些图 <code>g</code> 调用 <code>dfs(g)</code>。我们想要调用深度优先搜索的主要原因是计算每个顶点的完成时间。</li>
<li>以完成时间的递减顺序将顶点存储在列表中。</li>
<li>返回有序列表作为拓扑排序的结果。</li>
</ol>
<p>Figure 28 展示了在 Figure 26 所示的薄煎饼制作图上由 <code>dfs</code> 构建的深度优先森林。</p>
<p><img src="/assets/7.17.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.figure28.png" alt="7.17.拓扑排序.figure28"></p>
<p><em>Figure 28</em></p>
<p>最后，Figure 29 展示了将拓扑排序算法应用于我们的图形的结果。 现在所有的分支已被删除，我们知道确切的做煎饼的步骤顺序。</p>
<p><img src="/assets/7.17.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.figure29.png" alt="7.17.拓扑排序.figure29"></p>
<p><em>Figure 29</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.17.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/README/" data-id="clxzhp6k5002s1s8jcz917vbu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.16.深度优先搜索分析/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.16.%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%88%86%E6%9E%90/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.140Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-16-深度优先搜索分析"><a href="#7-16-深度优先搜索分析" class="headerlink" title="7.16.深度优先搜索分析"></a>7.16.深度优先搜索分析</h2><p>深度优先搜索的一般运行时间如下。 dfs 中的循环都在 $$O(V)$$ 中运行，不计入<code>dfsvisit</code> 中发生的情况，因为它们对图中的每个顶点执行一次。 在<code>dfsvisit</code> 中，对当前顶点的邻接表中的每个边执行一次循环。 由于只有当顶点为白色时，<code>dfsvisit</code> 才被递归调用，所以循环对图中的每个边或 $$O(E)$$ 执行最多一次。 因此，深度优先搜索的总时间是 $$O(V + E)$$。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.16.%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%88%86%E6%9E%90/README/" data-id="clxzhp6k6002w1s8jelii58as" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.15.通用深度优先搜索/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.15.%E9%80%9A%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.126Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-15-通用深度优先搜索"><a href="#7-15-通用深度优先搜索" class="headerlink" title="7.15.通用深度优先搜索"></a>7.15.通用深度优先搜索</h2><p>骑士之旅是深度优先搜索的特殊情况，其目的是创建最深的第一棵树，没有任何分支。更一般的深度优先搜索实际上更容易。它的目标是尽可能深的搜索，在图中连接尽可能多的节点，并在必要时创建分支。</p>
<p>甚至可能的是，深度优先搜索将创建多于一个树。当深度优先搜索算法创建一组树时，我们称之为深度优先森林。与广度优先搜索一样，我们的深度优先搜索使用前导链接来构造树。此外，深度优先搜索将在顶点类中使用两个附加的实例变量。新实例变量是发现和完成时间。发现时间跟踪首次遇到顶点之前的步骤数。完成时间是顶点着色为黑色之前的步骤数。正如我们看到的算法，节点的发现和完成时间提供了一些有趣的属性，我们可以在以后的算法中使用。</p>
<p>我们深度优先搜索的代码如 Listing 5 所示。由于 dfs 和它的辅助函数<code>dfsvisit</code> 这两个函数使用一个变量来跟踪调用 <code>dfsvisit</code> 的时间，所以我们选择将代码实现为继承自 <code>Graph</code> 类。此实现通过添加时间实例变量和两个方法 <code>dfs</code> 和 <code>dfsvisit</code>来扩展 <code>Graph</code> 类。看看第 11 行，你会注意到，<code>dfs</code> 方法在调用 <code>dfsvisit</code> 的图中所有的顶点迭代，这些节点是白色的。我们迭代所有节点而不是简单地从所选择的起始节点进行搜索的原因是为了确保图中的所有节点都被考虑到，没有顶点从深度优先森林中被遗漏。<code>for aVertex in self</code> 语句可能看起来不寻常，但请记住，在这种情况下，<code>self</code>是 <code>DFSGraph</code> 类的一个实例，遍历实例中的所有顶点是一件自然的事情。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DFSGraph</span>(<span class="title class_ inherited__">Graph</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> aVertex <span class="keyword">in</span> self:</span><br><span class="line">            aVertex.setColor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">            aVertex.setPred(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> aVertex <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> aVertex.getColor() == <span class="string">&#x27;white&#x27;</span>:</span><br><span class="line">                self.dfsvisit(aVertex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfsvisit</span>(<span class="params">self,startVertex</span>):</span><br><span class="line">        startVertex.setColor(<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        self.time += <span class="number">1</span></span><br><span class="line">        startVertex.setDiscovery(self.time)</span><br><span class="line">        <span class="keyword">for</span> nextVertex <span class="keyword">in</span> startVertex.getConnections():</span><br><span class="line">            <span class="keyword">if</span> nextVertex.getColor() == <span class="string">&#x27;white&#x27;</span>:</span><br><span class="line">                nextVertex.setPred(startVertex)</span><br><span class="line">                self.dfsvisit(nextVertex)</span><br><span class="line">        startVertex.setColor(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        self.time += <span class="number">1</span></span><br><span class="line">        startVertex.setFinish(self.time)</span><br></pre></td></tr></table></figure>

<p><em>Listing 5</em></p>
<p>虽然我们 <code>bfs</code> 的实现只对有一条路径回到开始的路径的节点感兴趣，但是有可能创建一个宽度优先森林，其表示图中的所有节点之间的最短路径。我们把这作为一个练习。在接下来的两个算法中，我们将看到为什么跟踪深度优先森林的深度很重要。</p>
<p><code>dfsvisit</code> 方法从名为 <code>startVertex</code> 的单个顶点开始，并尽可能深地探查所有相邻的白色顶点。如果仔细查看 <code>dfsvisit</code> 的代码并将其与广度优先搜索进行比较，应该注意的是，<code>dfsvisit</code> 算法几乎与 <code>bfs</code> 相同，除了在内部 for 循环的最后一行，<code>dfsvisit</code> 将自行递归调用以继续在更深的级别搜索，而 <code>bfs</code> 将节点添加到队列以供稍后探查。有趣的是，<code>bfs</code> 使用队列，<code>dfsvisit</code> 使用栈。你在代码中没有看到栈，但是它在 <code>dfsvisit</code> 的递归调用中是隐含的。</p>
<p>以下图的序列展示了针对小图的深度优先搜索算法。在这些图中，虚线指示检查的边，但是在边的另一端的节点已经被添加到深度优先树。在代码中，通过检查另一个节点的颜色是非白色的。</p>
<p>搜索从图的顶点 A 开始（Figure 14）。由于所有顶点在搜索开始时都是白色的，所以算法访问顶点 A。访问顶点的第一步是将颜色设置为灰色，这表示正在探索顶点，并且将发现时间设置为1，由于顶点 A 具有两个相邻的顶点（B，D），因此每个顶点也需要被访问。我们将做出任意决定，我们将按字母顺序访问相邻顶点。</p>
<p>接下来访问顶点B（Figure 15），因此其颜色设置为灰色并且其发现时间被设置为 2。顶点 B 也与两个其他节点（C，D）相邻，因此我们将遵循字母顺序和访问节点 C 接下来。</p>
<p>访问顶点 C（Figure16）使我们到树的一个分支的末端。在将节点灰色着色并将其发现时间设置为 3 之后，算法还确定没有与 C 相邻的顶点。这意味着我们完成了对节点 C 的探索，因此我们可以将顶点着色为黑色，并将完成时间设置为 4，在Figure 17 中，可以看到我们的搜索的状态。</p>
<p>由于顶点 C 是一个分支的结束，我们现在返回到顶点 B，继续探索与 B 相邻的节点。从 B 中探索的唯一额外的顶点是 D，所以我们现在可以访问 D（Figure 18），并继续搜索顶点 D。顶点 D 快速引导我们到顶点 E（Figure 19）。顶点 E 具有两个相邻的顶点 B 和 F 。通常我们将按字母顺序探索这些相邻顶点，但是由于 B 已经是灰色的，所以算法识别出它不应该访问 B，因为这样做会将算法置于循环中！因此，继续探索列表中的下一个顶点，即 F（Figure 20）。</p>
<p>顶点 F 只有一个相邻的顶点 C，但由于 C 是黑色的，没有别的东西可以探索，算法已经到达另一个分支的结束。从这里开始，你将在 Figure 21至 Figure 25中看到算法运行回到第一个节点，设置完成时间和着色顶点为黑色。</p>
<p><img src="/assets/7.15.%E9%80%9A%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.figure14.png" alt="7.15.通用深度优先搜索.figure14"></p>
<p><img src="/assets/7.15.%E9%80%9A%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.figure14-2.png" alt="7.15.通用深度优先搜索.figure14-2"></p>
<p><img src="/assets/7.15.%E9%80%9A%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.figure14-3.png" alt="7.15.通用深度优先搜索.figure14-3"></p>
<p><em>Figure 14-25</em></p>
<p>每个节点的开始和结束时间展示一个称为 <code>括号属性</code> 的属性。 该属性意味着深度优先树中的特定节点的所有子节点具有比它们的父节点更晚的发现时间和更早的完成时间。 Figure 26 展示了由深度优先搜索算法构造的树。</p>
<p><img src="/assets/7.15.%E9%80%9A%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.figure26.png" alt="7.15.通用深度优先搜索.figure26"></p>
<p><em>Figure 26</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.15.%E9%80%9A%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/" data-id="clxzhp6k5002q1s8j5cb7dtrp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.14.骑士之旅分析/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.14.%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%88%86%E6%9E%90/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.110Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-14-骑士之旅分析"><a href="#7-14-骑士之旅分析" class="headerlink" title="7.14.骑士之旅分析"></a>7.14.骑士之旅分析</h2><p>有最后关于骑士之旅一个有趣的话题，然后我们将继续到深度优先搜索的通用版本。主题是性能。特别是，<code>knightTour</code> 对于你选择下一个要访问的顶点的方法非常敏感。例如，在一个5乘5的板上，你可以在快速计算机上处理路径花费大约1.5秒。但是如果你尝试一个 $$8 \times 8$$ 的板，会发生什么？在这种情况下，根据计算机的速度，你可能需要等待半小时才能获得结果！这样做的原因是我们到目前为止所实现的骑士之旅问题是大小为 $$O(k^N)$$ 的指数算法，其中 N 是棋盘上的方格数，k 是小常数。Figure 12 可以帮助我们搞清楚为什么会这样。树的根表示搜索的起点。从那里，算法生成并检查骑士可以做出的每个可能的移动。正如我们之前注意到的，可能的移动次数取决于骑士在板上的位置。在角落只有两个合法的动作，在角落邻近的正方形有三个，在板的中间有八个。Figure 13 展示了板上每个位置可能的移动次数。在树的下一级，再次有 2 到 8 个可能的下一个移动。要检查的可能位置的数量对应于搜索树中的节点的数量。</p>
<p><img src="/assets/7.14.%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%88%86%E6%9E%90.figure12-13.png" alt="7.14.骑士之旅分析.figure12-13"></p>
<p><em>Figure 12-13</em></p>
<p>我们已经看到，高度 N 的二叉树中的节点数量是 $$2^{N+1} - 1$$。对于具有可以具有多达八个孩子而不是两个节点的树，节点的数量要大得多。因为每个节点的分支因子是可变的，我们可以使用平均分支因子估计节点的数量。重要的是要注意，这个算法是指数：$$k^{N+1} - 1$$，其中 k 是板的平均分支因子。让我们看看这增长有多快！对于 $$5 \times 5$$ 的板，树将是 25 级深，或者 N &#x3D; 24，将第一级算为级 0。平均分支因子是 k &#x3D; 3.8 因此，搜索树中的节点数量是 $$3.8^{25} - 1$$ 或$$3.12 \times 10^{14}$$ 。对于 6x6 板，k &#x3D; 4.4，有 $$1.5 \times 10^{23}$$ 个节点，对于常规的 8x8 棋盘，k &#x3D; 5.25 ，有 $$1.3 \times 10^{46}$$ 。当然，由于问题有多个解决方案，我们不必去探索每个节点，但是我们必须探索的节点的小数部分只是一个不会改变问题的指数性质的常数乘数。我们将把它作为一个练习，看看你是否可以表示k 作为板的大小的函数。</p>
<p>幸运的是有一种方法来加速八乘八的情况，使其在一秒钟内运行完成。在下面的列表中，我们将展示加速 <code>knightTour</code> 的代码。这个函数（见Listing 4），被称为 <code>orderbyAvail</code> 将被用来代替上面代码中对 <code>u.getConnections</code> 的调用。<code>orderByAvail</code> 函数中的关键是第 10 行。此行确保我们选择具有最少可用移动的下一个顶点。你可能认为这具有相反效果; 为什么不选择具有最多可用移动的节点？你可以通过运行该程序并在排序后插入行<code>resList.reverse()</code> 来尝试该方法。</p>
<p>使用具有最多可用移动的顶点作为路径上的下一个顶点的问题是，它倾向于让骑士在游览中早访问中间的方格。当这种情况发生时，骑士很容易陷入板的一侧，在那里它不能到达在板的另一侧的未访问的方格。另一方面，访问具有最少可用移动的方块首先推动骑士访问围绕板的边缘的方块。这确保了骑士能够尽早地访问难以到达的角落，并且只有在必要时才使用中间的方块跳过棋盘。利用这种知识加速算法被称为启发式。人类每天都使用启发式来帮助做出决策，启发式搜索通常用于人工智能领域。这个特定的启发式称为 <code>Warnsdorff</code> 算法，由 <code>H. C. Warnsdorff</code> 命名，他在 1823 年发表了他的算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">orderByAvail</span>(<span class="params">n</span>):</span><br><span class="line">    resList = []</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> n.getConnections():</span><br><span class="line">        <span class="keyword">if</span> v.getColor() == <span class="string">&#x27;white&#x27;</span>:</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> v.getConnections():</span><br><span class="line">                <span class="keyword">if</span> w.getColor() == <span class="string">&#x27;white&#x27;</span>:</span><br><span class="line">                    c = c + <span class="number">1</span></span><br><span class="line">            resList.append((c,v))</span><br><span class="line">    resList.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> [y[<span class="number">1</span>] <span class="keyword">for</span> y <span class="keyword">in</span> resList]</span><br><span class="line">Next Section - <span class="number">7.15</span>. General Depth First Search</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.14.%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%88%86%E6%9E%90/README/" data-id="clxzhp6k5002p1s8j9u0w809y" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.13.实现骑士之旅/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.13.%E5%AE%9E%E7%8E%B0%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.077Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-13-实现骑士之旅"><a href="#7-13-实现骑士之旅" class="headerlink" title="7.13.实现骑士之旅"></a>7.13.实现骑士之旅</h2><p>我们将用来解决骑士旅游问题的搜索算法称为 深度优先搜索（DFS）。尽管在前面部分中讨论的广度优先搜索算法一次建立一个搜索树，但是深度优先搜索通过尽可能深地探索树的一个分支来创建搜索树。在本节中，我们将介绍实现深度优先搜索的两种算法。我们将看到的第一个算法通过明确地禁止一个节点被访问多次来直接解决骑士的旅行问题。第二种实现是更通用的，但是允许在构建树时多次访问节点。第二个版本在后续部分中用于开发其他图形算法。</p>
<p>图的深度优先搜索正是我们需要的，来找到有 63 个边的路径。我们将看到，当深度优先搜索算法找到死角（图中没有可移动的地方）时，它将回到下一个最深的顶点，允许它进行移动。</p>
<p><code>knightTour</code> 函数有四个参数：<code>n</code> ，搜索树中的当前深度; <code>path</code>，到此为止访问的顶点的列表; <code>u</code>，图中我们希望探索的顶点; <code>limit</code> 路径中的节点数。 <code>knightTour</code> 函数是递归的。当调用 <code>knightTour</code> 函数时，它首先检查基本情况。如果我们有一个包含 <code>64</code> 个顶点的路径，我们状态为 <code>True</code> 的 <code>knightTour</code> 返回，表示我们找到了一个成功的线路。如果路径不够长，我们继续通过选择一个新的顶点来探索一层，并对这个顶点递归调用knightTour。</p>
<p>DFS 还使用颜色来跟踪图中的哪些顶点已被访问。未访问的顶点是白色的，访问的顶点是灰色的。如果已经探索了特定顶点的所有邻居，并且我们尚未达到64个顶点的目标长度，我们已经到达死胡同。当我们到达死胡同时，我们必须回溯。当我们从状态为 False 的 knightTour 返回时，发生回溯。在广度优先搜索中，我们使用一个队列来跟踪下一个要访问的顶点。由于深度优先搜索是递归的，我们隐式使用一个栈来帮助我们回溯。当我们从第 11 行的状态为 False 的<code>knightTour</code> 调用返回时，我们保持在 while 循环中，并查看 <code>nbrList</code> 中的下一个顶点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph, Vertex</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knightTour</span>(<span class="params">n,path,u,limit</span>):</span><br><span class="line">        u.setColor(<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        path.append(u)</span><br><span class="line">        <span class="keyword">if</span> n &lt; limit:</span><br><span class="line">            nbrList = <span class="built_in">list</span>(u.getConnections())</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nbrList) <span class="keyword">and</span> <span class="keyword">not</span> done:</span><br><span class="line">                <span class="keyword">if</span> nbrList[i].getColor() == <span class="string">&#x27;white&#x27;</span>:</span><br><span class="line">                    done = knightTour(n+<span class="number">1</span>, path, nbrList[i], limit)</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> done:  <span class="comment"># prepare to backtrack</span></span><br><span class="line">                path.pop()</span><br><span class="line">                u.setColor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> done</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>让我们看看一个简单的例子 <code>knightTour</code> 。你可以按照搜索的步骤参考下面的图。对于这个例子，我们假设对第 6 行的 <code>getConnections</code> 方法的调用按字母顺序对节点排序。我们首先调用 <code>knightTour(0，path，A，6)</code></p>
<p>Figure 中 <code>knightTour</code> 从节点 A 开始.与 A 相邻的节点是 B 和 D。由于 B 在字母 D 之前，DFS选择 B 展开下一个，如 Figure 4 所示。当<code>knightTour</code> 被递归调用时，开始从 B 开始探寻。 B 与 C 和 D 相邻，所以 knightTour 选择接下来探索 C。然而，如 Figure 5 所示，节点 C 是没有相邻节点的死胡同。此时，我们将节点 C 的颜色更改为白色。对 knightTour 的调用返回值 False。从递归调用的返回有效地将搜索回溯到顶点B（参见Figure 6）。列表中要探索的下一个顶点是顶点 D，因此 <code>knightTour</code> 使递归调用移动到节点 D（参见 Figure 7）。从顶点 D 开始，<code>knightTour</code> 可以继续进行递归调用，直到我们再次到达节点 C（参见Figure 8，Figure 9和 Figure 10）。然而，当我们到达节点C时，测试 <code>n &lt;limit</code> 失败，所以我们知道已经耗尽了图中的所有节点。在这一点上，我们可以返回 True，表示我们已经成功地浏览了图。当我们返回列表时，路径具有值 <code>[A，B，D，E，F，C]</code>，这是我们需要遍历图以访问每个节点的顺序。</p>
<p><img src="/assets/7.13.%E5%AE%9E%E7%8E%B0%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85.figure3-1.png" alt="7.13.实现骑士之旅.figure3-1"></p>
<p><img src="/assets/7.13.%E5%AE%9E%E7%8E%B0%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85.figure3-2.png" alt="7.13.实现骑士之旅.figure3-2"></p>
<p><em>Figure 3-10</em></p>
<p>Figure 11 展示了一个 $$8 \times 8$$ 板的完整遍历。有许多可能的路径; 一些是对称的。 通过一些修改，你可以使遍历开始和结束在同一个正方形。</p>
<p><img src="/assets/7.13.%E5%AE%9E%E7%8E%B0%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85.figure3.png" alt="7.13.实现骑士之旅.figure3"></p>
<p><em>Figure 10</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.13.%E5%AE%9E%E7%8E%B0%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85/README/" data-id="clxzhp6k4002o1s8jaeyhfgku" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.12.构建骑士之旅图/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.12.%E6%9E%84%E5%BB%BA%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%9B%BE/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.068Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-12-构建骑士之旅图"><a href="#7-12-构建骑士之旅图" class="headerlink" title="7.12.构建骑士之旅图"></a>7.12.构建骑士之旅图</h2><p>为了将骑士的旅游问题表示为图，我们将使用以下两个点：棋盘上的每个正方形可以表示为图形中的一个节点。 骑士的每个合法移动可以表示为图形中的边。 Figure 1 展示了骑士的移动以及图中的对应边。</p>
<p><img src="/assets/7.12.%E6%9E%84%E5%BB%BA%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%9B%BE.figure1.png" alt="7.12.构建骑士之旅图.figure1"></p>
<p><em>Figure 1</em></p>
<p>要构建一个 <code>n*n</code> 的完整图，我们可以使用 Listing 1 中所示的 Python 函数。<code>knightGraph</code> 函数在整个板上进行一次遍历。 在板上的每个方块上，<code>knightGraph</code> 函数调用 <code>genLegalMoves</code> ，为板上的位置创建一个移动列表。 所有移动在图形中转换为边。 另一个帮助函数 <code>posToNodeId</code> 按照行和列将板上的位置转换为类似于 Figure 1 所示的顶点数的线性顶点数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knightGraph</span>(<span class="params">bdSize</span>):</span><br><span class="line">    ktGraph = Graph()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bdSize):</span><br><span class="line">       <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(bdSize):</span><br><span class="line">           nodeId = posToNodeId(row,col,bdSize)</span><br><span class="line">           newPositions = genLegalMoves(row,col,bdSize)</span><br><span class="line">           <span class="keyword">for</span> e <span class="keyword">in</span> newPositions:</span><br><span class="line">               nid = posToNodeId(e[<span class="number">0</span>],e[<span class="number">1</span>],bdSize)</span><br><span class="line">               ktGraph.addEdge(nodeId,nid)</span><br><span class="line">    <span class="keyword">return</span> ktGraph</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posToNodeId</span>(<span class="params">row, column, board_size</span>):</span><br><span class="line">    <span class="keyword">return</span> (row * board_size) + column</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p><code>genLegalMoves</code> 函数（Listing 2）使用板上骑士的位置，并生成八个可能移动中的一个。 <code>legalCoord</code> 辅助函数（Listing 2）确保生成的特定移动仍在板上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">genLegalMoves</span>(<span class="params">x,y,bdSize</span>):</span><br><span class="line">    newMoves = []</span><br><span class="line">    moveOffsets = [(-<span class="number">1</span>,-<span class="number">2</span>),(-<span class="number">1</span>,<span class="number">2</span>),(-<span class="number">2</span>,-<span class="number">1</span>),(-<span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">                   ( <span class="number">1</span>,-<span class="number">2</span>),( <span class="number">1</span>,<span class="number">2</span>),( <span class="number">2</span>,-<span class="number">1</span>),( <span class="number">2</span>,<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> moveOffsets:</span><br><span class="line">        newX = x + i[<span class="number">0</span>]</span><br><span class="line">        newY = y + i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> legalCoord(newX,bdSize) <span class="keyword">and</span> \</span><br><span class="line">                        legalCoord(newY,bdSize):</span><br><span class="line">            newMoves.append((newX,newY))</span><br><span class="line">    <span class="keyword">return</span> newMoves</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">legalCoord</span>(<span class="params">x,bdSize</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt; bdSize:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>Figure 2 展示了一个 $$8 \times 8$$ 板的可能移动的完整图。图中有正好 336 个边。 注意，与板的边相对应的顶点具有比板中间的顶点更少的连接（移动数）。 再次我们可以看到图的稀疏。 如果图形完全连接，则会有 4,096 个边。 由于只有336 个边，邻接矩阵只有 8.2％ 填充率。</p>
<p><img src="/assets/7.12.%E6%9E%84%E5%BB%BA%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%9B%BE.figure2.png" alt="7.12.构建骑士之旅图.figure2"></p>
<p><em>Figure 2</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.12.%E6%9E%84%E5%BB%BA%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85%E5%9B%BE/README/" data-id="clxzhp6k4002n1s8j0u9u5qle" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.9.%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.8.%E6%9E%84%E5%BB%BA%E5%AD%97%E6%A2%AF%E5%9B%BE/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.7.%E5%AD%97%E6%A2%AF%E7%9A%84%E9%97%AE%E9%A2%98/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.6.%E5%AE%9E%E7%8E%B0/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.5.%E9%82%BB%E6%8E%A5%E8%A1%A8/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FLITl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>