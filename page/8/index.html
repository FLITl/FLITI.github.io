<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FLITl的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些感想，一些技术，一些生活。">
<meta property="og:type" content="website">
<meta property="og:title" content="FLITl的博客">
<meta property="og:url" content="http://jackfrued.top/page/8/index.html">
<meta property="og:site_name" content="FLITl的博客">
<meta property="og:description" content="一些感想，一些技术，一些生活。">
<meta property="og:locale">
<meta property="article:author" content="FLITl">
<meta property="article:tag" content="反思，技术，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FLITl的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FLITl的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天命之谓性；率性之谓道；修道之谓教。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jackfrued.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.7.符号匹配/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.7.%E7%AC%A6%E5%8F%B7%E5%8C%B9%E9%85%8D/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.627Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-7-符号匹配"><a href="#3-7-符号匹配" class="headerlink" title="3.7.符号匹配"></a>3.7.符号匹配</h2><p>上面显示的匹配括号问题是许多编程语言都会出现的一般情况的特定情况。匹配和嵌套不同种类的开始和结束符号的情况经常发生。例如，在 Python 中，方括号 <code>[</code> 和 <code>]</code> 用于列表，花括号 <code>&#123;</code> 和 <code>&#125;</code> 用于字典。括号 <code>(</code> 和 <code>)</code> 用于元组和算术表达式。只要每个符号都能保持自己的开始和结束关系，就可以混合符号。符号字符串如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; ( [ ] [ ] ) &#125; ( ) &#125;</span><br><span class="line"></span><br><span class="line">[ [ &#123; &#123; ( ( ) ) &#125; &#125; ] ]</span><br><span class="line"></span><br><span class="line">[ ] [ ] [ ] ( ) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>这些被恰当的匹配了，因为不仅每个开始符号都有对应的结束符号，而且符号的类型也匹配。</p>
<p>相反这些字符串没法匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">( [ ) ]</span><br><span class="line"></span><br><span class="line">( ( ( ) ] ) )</span><br><span class="line"></span><br><span class="line">[ &#123; ( ) ]</span><br></pre></td></tr></table></figure>

<p>上节的简单括号检查程序可以轻松的扩展处理这些新类型的符号。回想一下，每个开始符号被简单的压入栈中，等待匹配的结束符号出现。当出现结束符号时，唯一的区别是我们必须检查确保它正确匹配栈顶部开始符号的类型。如果两个符号不匹配，则字符串不匹配。如果整个字符串都被处理完并且没有什么留在栈中，则字符串匹配。</p>
<p>Python 程序见 ActiveCode 1。唯一的变化是 16 行，我们称之为辅助函数匹配。必须检查栈中每个删除的符号，以查看它是否与当前结束符号匹配。如果不匹配，则布尔变量 balanced 被设置为 False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parChecker</span>(<span class="params">symbolString</span>):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = <span class="literal">True</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(symbolString) <span class="keyword">and</span> balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> <span class="string">&quot;([&#123;&quot;</span>:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">                balanced = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                top = s.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matches(top,symbol):</span><br><span class="line">                       balanced = <span class="literal">False</span></span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matches</span>(<span class="params"><span class="built_in">open</span>,close</span>):</span><br><span class="line">    opens = <span class="string">&quot;([&#123;&quot;</span></span><br><span class="line">    closers = <span class="string">&quot;)]&#125;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> opens.index(<span class="built_in">open</span>) == closers.index(close)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(parChecker(<span class="string">&#x27;&#123;&#123;([][])&#125;()&#125;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(parChecker(<span class="string">&#x27;[&#123;()]&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>
<p>这两个例子表明，栈是计算机语言结构处理非常重要的数据结构。几乎你能想到的任何嵌套符号必须按照平衡匹配的顺序。栈还有其他重要的用途，我们将在接下来的部分讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.7.%E7%AC%A6%E5%8F%B7%E5%8C%B9%E9%85%8D/README/" data-id="clxzhp6jt00111s8jdu9cfltk" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.6.简单括号匹配/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.6.%E7%AE%80%E5%8D%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.620Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-6-简单括号匹配"><a href="#3-6-简单括号匹配" class="headerlink" title="3.6.简单括号匹配"></a>3.6.简单括号匹配</h2><p>我们现在把注意力转向使用栈解决真正的计算机问题。你会这么写算术表达式</p>
<p><code>(5+6)*(7+8)/(4+3)</code></p>
<p>其中括号用于命令操作的执行。你可能也有一些语言的经验，如 Lisp 的构造</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> square(<span class="name">n</span>)</span><br><span class="line">     (<span class="name">*</span> n n))</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为 square 的函数，它将返回参数的 n 的平方。 Lisp 使用大量的圆括号是臭名昭著的。</p>
<p>在这两个例子中，括号必须以匹配的方式出现。括号匹配意味着每个开始符号具有相应的结束符号，并且括号能被正确嵌套。考虑下面正确匹配的括号字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(()()()())</span><br><span class="line"></span><br><span class="line">(((())))</span><br><span class="line"></span><br><span class="line">(()((())()))</span><br></pre></td></tr></table></figure>

<p>对比那些不匹配的括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((((((())</span><br><span class="line"></span><br><span class="line">()))</span><br><span class="line"></span><br><span class="line">(()()(()</span><br></pre></td></tr></table></figure>

<p>区分括号是否匹配的能力是识别很多编程语言结构的重要部分。具有挑战的是如何编写一个算法，能够从左到右读取一串符号，并决定符号是否平衡。为了解决这个问题，我们需要做一个重要的观察。从左到右处理符号时，最近开始符号必须与下一个关闭符号相匹配(见 Figure 4)。此外，处理的第一个开始符号必须等待直到其匹配最后一个符号。结束符号以相反的顺序匹配开始符号。他们从内到外匹配。这是一个可以用栈解决问题的线索。</p>
<p><img src="/assets/3.6.%E7%AE%80%E5%8D%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.simpleparcheck.png" alt="3.6.简单括号匹配.simpleparcheck"></p>
<p><em>Figure 4</em></p>
<p>一旦你认为栈是保存括号的恰当的数据结构，算法是很直接的。从空栈开始，从左到右处理括号字符串。如果一个符号是一个开始符号，将其作为一个信号，对应的结束符号稍后会出现。另一方面，如果符号是结束符号，弹出栈，只要弹出栈的开始符号可以匹配每个结束符号，则括号保持匹配状态。如果任何时候栈上没有出现符合开始符号的结束符号，则字符串不匹配。最后，当所有符号都被处理后，栈应该是空的。实现此算法的 Python 代码见 ActiveCode 1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parChecker</span>(<span class="params">symbolString</span>):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = <span class="literal">True</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(symbolString) <span class="keyword">and</span> balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        <span class="keyword">if</span> symbol == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">                balanced = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.pop()</span><br><span class="line"></span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(parChecker(<span class="string">&#x27;((()))&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(parChecker(<span class="string">&#x27;(()&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.6.%E7%AE%80%E5%8D%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/README/" data-id="clxzhp6js000z1s8j5ye02dta" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.5.Python实现栈/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.5.Python%E5%AE%9E%E7%8E%B0%E6%A0%88/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.616Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-5-Python实现栈"><a href="#3-5-Python实现栈" class="headerlink" title="3.5.Python实现栈"></a>3.5.Python实现栈</h2><p>现在我们已经将栈清楚地定义了抽象数据类型，我们将把注意力转向使用 Python 实现栈。回想一下，当我们给抽象数据类型一个物理实现时，我们将实现称为数据结构。</p>
<p>正如我们在第1章中所描述的，在 Python 中，与任何面向对象编程语言一样，抽象数据类型（如栈）的选择的实现是创建一个新类。栈操作实现为类的方法。此外，为了实现作为元素集合的栈，使用由 Python 提供的原语集合的能力是有意义的。 我们将使用列表作为底层实现。</p>
<p>回想一下，Python 中的列表类提供了有序集合机制和一组方法。例如，如果我们有列表 [2,5,3,6,7,4]，我们只需要确定列表的哪一端将被认为是栈的顶部。一旦确定，可以使用诸如 append 和 pop 的列表方法来实现操作。</p>
<p>以下栈实现（ActiveCode 1）假定列表的结尾将保存栈的顶部元素。随着栈增长（push 操作），新项将被添加到列表的末尾。 pop 也操作列表末尾的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">         self.items = []</span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item</span>):</span><br><span class="line">         self.items.append(item)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> self.items[<span class="built_in">len</span>(self.items)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>
<p>记住我们只定义类的实现，我们需要创建一个栈，然后使用它。ActiveCode 2 展示了我们通过实例化 Stack 类执行 Table 1中的操作。注意，Stack 类的定义是从 pythonds 模块导入的。</p>
<blockquote>
<p><strong>Note</strong><br>pythonds 模块包含本书中讨论的所有数据结构的实现。它根据以下部分构造：基本数据类型，树和图。 该模块可以从 <a href="http://www.pythonworks.org/pythonds">pythonworks.org</a>下载。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line">s=Stack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.isEmpty())</span><br><span class="line">s.push(<span class="number">4</span>)</span><br><span class="line">s.push(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.peek())</span><br><span class="line">s.push(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(s.size())</span><br><span class="line"><span class="built_in">print</span>(s.isEmpty())</span><br><span class="line">s.push(<span class="number">8.4</span>)</span><br><span class="line"><span class="built_in">print</span>(s.pop())</span><br><span class="line"><span class="built_in">print</span>(s.pop())</span><br><span class="line"><span class="built_in">print</span>(s.size())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 2</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.5.Python%E5%AE%9E%E7%8E%B0%E6%A0%88/README/" data-id="clxzhp6jt00101s8j3scjepp9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.4.栈的抽象数据类型/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.608Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-4-栈的抽象数据类型"><a href="#3-4-栈的抽象数据类型" class="headerlink" title="3.4.栈的抽象数据类型"></a>3.4.栈的抽象数据类型</h2><p>栈的抽象数据类型由以下结构和操作定义。如上所述，栈被构造为项的有序集合，其中项被添加和从末端移除的位置称为“顶部”。栈是有序的 LIFO 。栈操作如下。</p>
<ul>
<li>Stack() 创建一个空的新栈。 它不需要参数，并返回一个空栈。</li>
<li>push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容。</li>
<li>pop() 从栈中删除顶部项。它不需要参数并返回 item 。栈被修改。</li>
<li>peek() 从栈返回顶部项，但不会删除它。不需要参数。 不修改栈。</li>
<li>isEmpty() 测试栈是否为空。不需要参数，并返回布尔值。</li>
<li>size() 返回栈中的 item 数量。不需要参数，并返回一个整数。</li>
</ul>
<p>例如，s 是已经创建的空栈，Table1 展示了栈操作序列的结果。栈中，顶部项列在最右边。<br><img src="/assets/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="3.4.栈的抽象数据类型.table1"><br><em>Table1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" data-id="clxzhp6js000y1s8jbtub05ma" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.3.什么是栈/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.596Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-3-什么是栈"><a href="#3-3-什么是栈" class="headerlink" title="3.3.什么是栈"></a>3.3.什么是栈</h2><p>栈（有时称为“后进先出栈”）是一个项的有序集合，其中添加移除新项总发生在同一端。这一端通常称为“顶部”。与顶部对应的端称为“底部”。</p>
<p>栈的底部很重要，因为在栈中靠近底部的项是存储时间最长的。最近添加的项是最先会被移除的。这种排序原则有时被称为 LIFO，后进先出。它基于在集合内的时间长度做排序。较新的项靠近顶部，较旧的项靠近底部。</p>
<p>栈的例子很常见。几乎所有的自助餐厅都有一堆托盘或盘子，你从顶部拿一个，就会有一个新的托盘给下一个客人。想象桌上有一堆书(Figure 1), 只有顶部的那本书封面可见，要看到其他书的封面，只有先移除他们上面的书。Figure 2 展示了另一个栈，包含了很多 Python 对象。</p>
<p><img src="/assets/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88.png" alt="3.3.什么是栈"><br><em>Figure 1</em></p>
<p><img src="/assets/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88.primitive.png" alt="3.3.什么是栈.primitive"><br><em>Figure 2</em></p>
<p>和栈相关的最有用的想法之一来自对它的观察。假设从一个干净的桌面开始，现在把书一本本叠起来，你在构造一个栈。考虑下移除一本书会发生什么。移除的顺序跟刚刚被放置的顺序相反。栈之所以重要是因为它能反转项的顺序。插入跟删除顺序相反，Figure 3 展示了 Python 数据对象创建和删除的过程，注意观察他们的顺序。</p>
<p><img src="/assets/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88.simplereversal.png" alt="3.3.什么是栈.simplereversa"><br><em>Figure 3</em></p>
<p>想想这种反转的属性，你可以想到使用计算机的时候所碰到的例子。例如，每个 web 浏览器都有一个返回按钮。当你浏览网页时，这些网页被放置在一个栈中（实际是网页的网址）。你现在查看的网页在顶部，你第一个查看的网页在底部。如果按‘返回’按钮，将按相反的顺序浏览刚才的页面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88/README/" data-id="clxzhp6js000v1s8jhnqy3reu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.24.总结/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.24.%E6%80%BB%E7%BB%93/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.592Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-24-总结"><a href="#3-24-总结" class="headerlink" title="3.24.总结"></a>3.24.总结</h2><ul>
<li>线性数据结构以有序的方式保存它们的数据。</li>
<li>栈是维持 LIFO，后进先出，排序的简单数据结构。</li>
<li>栈的基本操作是 <code>push</code>，<code>pop</code>和 <code>isEmpty</code>。</li>
<li>队列是维护 FIFO（先进先出）排序的简单数据结构。</li>
<li>队列的基本操作是 <code>enqueue</code>，<code>dequeue</code> 和 <code>isEmpty</code>。</li>
<li>前缀，中缀和后缀都是写表达式的方法。</li>
<li>栈对于设计计算解析表达式算法非常有用。</li>
<li>栈可以提供反转特性。</li>
<li>队列可以帮助构建定时仿真。</li>
<li>模拟使用随机数生成器来创建真实情况，并帮助我们回答“假设”类型的问题。</li>
<li><code>Deques</code> 是允许类似栈和队列的混合行为的数据结构。</li>
<li><code>deque</code> 的基本操作是 <code>addFront</code>，<code>addRear</code>，<code>removeFront</code>，<code>removeRear</code> 和 <code>isEmpty</code>。</li>
<li>列表是项的集合，其中每个项目保存相对位置。</li>
<li>链表实现保持逻辑顺序，而不需要物理存储要求。</li>
<li>修改链表头是一种特殊情况。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.24.%E6%80%BB%E7%BB%93/README/" data-id="clxzhp6js000x1s8j9e0d6y63" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.23.实现有序列表/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.580Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-23-实现有序列表"><a href="#3-23-实现有序列表" class="headerlink" title="3.23.实现有序列表"></a>3.23.实现有序列表</h2><p>为了实现有序列表，我们必须记住项的相对位置是基于一些潜在的特性。上面给出的整数的有序列表<code>17,26,31,54,77</code> 和 <code>93</code> 可以由 Figure 15 所示的链接结构表示。节点和链接结构表示项的相对位置。</p>
<p><img src="/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure15.png" alt="3.23.实现有序列表.figure15"></p>
<p><em>Figure 15</em></p>
<p>为了实现 OrderedList 类，我们将使用与前面看到的无序列表相同的技术。再次，<code>head</code> 的引用为 <code>None</code> 表示为空链表（参见 Listing 8）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 8</em></p>
<p>当我们考虑有序列表的操作时，我们应该注意，<code>isEmpty</code> 和<code>size</code> 方法可以与无序列表一样实现，因为它们只处理链表中的节点数量，而不考虑实际项值。同样，<code>remove</code> 方法将正常工作，因为我们仍然需要找到该项，然后删除它。剩下的两个方法，<code>search</code> 和 <code>add</code>，将需要一些修改。</p>
<p>搜索无序列表需要我们一次遍历一个节点，直到找到我们正在寻找的节点或者没找到节点（None）。事实证明，相同的方法在有序列表也有效。然而，在项不在链表中的情况下，我们可以利用该顺序来尽快停止搜索。</p>
<p>例如，Figure 16 展示了有序链表搜索值 45 。从链表的头部开始遍历，首先与 <code>17</code> 进行比较。由于 <code>17</code> 不是我们正在寻找的项，移动到下一个节点 <code>26</code> 。再次，这不是我们想要的，继续到 <code>31</code>，然后再到 <code>54</code> 。在这一点上，有一些不同。由于 <code>54</code> 不是我们正在寻找的项，我们以前的方法是继续向前迭代。然而，由于这是有序列表，一旦节点中的值变得大于我们正在搜索的项，搜索就可以停止并返回 False 。该项不可能存在于后面的链表中。</p>
<p><img src="/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure16.png" alt="3.23.实现有序列表.figure16"></p>
<p><em>Figure 16</em></p>
<p>Listing 9 展示了完整的搜索方法。通过添加另一个布尔变量 <code>stop</code> 并将其初始化为 <code>False</code>（第4行），很容易合并上述新条件。 当 <code>stop</code> 是<code>False</code>（不停止）时，我们可以继续在列表中前进（第5行）。如果发现任何节点包含大于我们正在寻找的项的数据，我们将 <code>stop</code> 设置为 <code>True</code>（第9-10行）。其余行与无序列表搜索相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">    current = self.head</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    stop = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">        <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.getNext()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<p><em>Listing 9</em></p>
<p>最重要的需要修改的方法是 <code>add</code>。 回想一下，对于无序列表，<code>add</code> 方法可以简单地将新节点放置在链表的头部。 这是最简单的访问点。 不幸的是，这将不再适用于有序列表。需要在现有的有序列表中查找新项所属的特定位置。</p>
<p>假设我们有由 <code>17,26,54,77</code> 和 <code>93</code> 组成的有序列表，并且我们要添加值<code>31</code> 。 <code>add</code> 方法必须确定新项属于 <code>26</code> 到 <code>54</code> 之间。Figure 17 展示了我们需要的设置。正如我们前面解释的，我们需要遍历链表，寻找添加新节点的地方。我们知道，当我们迭代完节点（ <code>current</code> 变为 None）或 <code>current</code> 节点的值变得大于我们希望添加的项时，我们就找到了该位置。在我们的例子中，看到值 <code>54</code> 我们停止迭代。</p>
<p><img src="/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure17.png" alt="3.23.实现有序列表.figure17"></p>
<p><em>Figure 17</em></p>
<p>正如我们看到的无序列表，有必要有一个额外的引用，再次称为 <code>previous</code>，因为 <code>current</code> 不会提供对修改的节点的访问。 Listing 10 展示了完整的<code>add</code> 方法。 行 2-3 设置两个外部引用，行 9-10 允许 <code>previous</code> 每次通过迭代跟随 <code>current</code> 节点后面 。 条件（行5）允许迭代继续，只要有更多的节点，并且当前节点中的值不大于该项。 在任一种情况下，当迭代失败时，我们找到了新节点的位置。</p>
<p>该方法的其余部分完成 Figure17 所示的两步过程。一旦为该项创建了新节点，剩下的唯一问题是新节点是否将被添加在链表的开始处或某个中间位置。再次，<code>previous == None</code>（第13行）可以用来提供答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">    current = self.head</span><br><span class="line">    previous = <span class="literal">None</span></span><br><span class="line">    stop = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">        <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">            stop = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.getNext()</span><br><span class="line"></span><br><span class="line">    temp = Node(item)</span><br><span class="line">    <span class="keyword">if</span> previous == <span class="literal">None</span>:</span><br><span class="line">        temp.setNext(self.head)</span><br><span class="line">        self.head = temp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp.setNext(current)</span><br><span class="line">        previous.setNext(temp)</span><br></pre></td></tr></table></figure>

<p><em>Listing 10</em></p>
<h3 id="3-23-1-链表分析"><a href="#3-23-1-链表分析" class="headerlink" title="3.23.1.链表分析"></a>3.23.1.链表分析</h3><p>为了分析链表操作的复杂性，我们需要考虑它们是否需要遍历。考虑具有 n 个节点的链表。 <code>isEmpty</code> 方法是 $$O(1)$$，因为它需要一个步骤来检查头的引用为 <code>None</code>。另一方面，<code>size</code> 将总是需要 n 个步骤，因为不从头到尾地移动没法知道有多少节点在链表中。因此，长度为 $$O(n)$$。将项添加到无序列表始终是 $$O(1)$$，因为我们只是将新节点放置在链表的头部。但是，搜索和删除，以及添加有序列表，都需要遍历过程。虽然平均他们可能只需要遍历节点的一半，这些方法都是 $$O(n)$$，因为在最坏的情况下，都将处理列表中的每个节点。</p>
<p>你可能还注意到此实现的性能与早前针对 Python 列表给出的实际性能不同。这表明链表不是 Python 列表的实现方式。 Python 列表的实际实现基于数组的概念。我们在第 8 章中更详细地讨论这个问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/README/" data-id="clxzhp6js000w1s8jf265an7a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.22.有序列表抽象数据结构/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.22.%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.576Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-22-有序列表抽象数据结构"><a href="#3-22-有序列表抽象数据结构" class="headerlink" title="3.22.有序列表抽象数据结构"></a>3.22.有序列表抽象数据结构</h2><p>我们现在将考虑一种称为有序列表的列表类型。例如，如果上面所示的整数列表是有序列表（升序），则它可以写为 <code>17,26,31,54,77和93</code>。由于 17 是最小项，它占据第一位置。同样，由于 93 是最大的，它占据最后的位置。</p>
<p>有序列表的结构是项的集合，其中每个项保存基于项的一些潜在特性的相对位置。排序通常是升序或降序，并且我们假设列表项具有已经定义的有意义的比较运算。许多有序列表操作与无序列表的操作相同。</p>
<ul>
<li>OrderedList() 创建一个新的空列表。它不需要参数，并返回一个空列表。</li>
<li>add(item) 向列表中添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</li>
<li>remove(item) 从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li>
<li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li>
<li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li>
<li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li>
<li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li>
<li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li>
<li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.22.%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/README/" data-id="clxzhp6jq000t1s8j2tvm2aul" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.21.实现无序列表：链表/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.560Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-21-实现无序列表：链表"><a href="#3-21-实现无序列表：链表" class="headerlink" title="3.21.实现无序列表：链表"></a>3.21.实现无序列表：链表</h2><p>为了实现无序列表，我们将构造通常所知的链表。回想一下，我们需要确保我们可以保持项的相对定位。然而，没有要求我们维持在连续存储器中的定位。例如，考虑 Figure 1 中所示的项的集合。看来这些值已被随机放置。如果我们可以在每个项中保持一些明确的信息，即下一个项的位置（参见 Figure 2），则每个项的相对位置可以通过简单地从一个项到下一个项的链接来表示。</p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure1.png" alt="3.21.实现无序列表：链表.figure1"></p>
<p><em>Figure 1</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure2.png" alt="3.21.实现无序列表：链表.figure2"></p>
<p><em>Figure 2</em></p>
<p>要注意，必须明确地指定链表的第一项的位置。一旦我们知道第一个项在哪里，第一个项目可以告诉我们第二个是什么，等等。外部引用通常被称为链表的头。类似地，最后一个项需要知道没有下一个项。</p>
<h3 id="3-21-1-Node-类"><a href="#3-21-1-Node-类" class="headerlink" title="3.21.1.Node 类"></a>3.21.1.Node 类</h3><p>链表实现的基本构造块是节点。每个节点对象必须至少保存两个信息。首先，节点必须包含列表项本身。我们将这个称为节点的数据字段。此外，每个节点必须保存对下一个节点的引用。 Listing 1 展示了 Python 实现。要构造一个节点，需要提供该节点的初始数据值。下面的赋值语句将产生一个包含值 93 的节点对象（见 Figure 3）。应该注意，我们通常会如 Figure 4 所示表示一个节点对象。Node 类还包括访问，修改数据和访问下一个引用的常用方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,initdata</span>):</span><br><span class="line">        self.data = initdata</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self,newdata</span>):</span><br><span class="line">        self.data = newdata</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setNext</span>(<span class="params">self,newnext</span>):</span><br><span class="line">        self.<span class="built_in">next</span> = newnext</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>我们创建一个 Node 对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; temp = Node(93)</span><br><span class="line">&gt;&gt;&gt; temp.getData()</span><br><span class="line">93</span><br></pre></td></tr></table></figure>

<p>Python 引用值 None 将在 Node 类和链表本身发挥重要作用。引用 None 代表没有下一个节点。请注意在构造函数中，最初创建的节点 next 被设置为 None。有时这被称为 <code>接地节点</code>，因此我们使用标准接地符号表示对 None 的引用。将 None 显式的分配给初始下一个引用值是个好主意。</p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure3.png" alt="3.21.实现无序列表：链表.figure3"></p>
<p><em>Figure 3</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure4.png" alt="3.21.实现无序列表：链表.figure4"></p>
<p><em>Figure 4</em></p>
<h3 id="3-21-2-Unordered-List-类"><a href="#3-21-2-Unordered-List-类" class="headerlink" title="3.21.2.Unordered List 类"></a>3.21.2.Unordered List 类</h3><p>如上所述，无序列表将从一组节点构建，每个节点通过显式引用链接到下一个节点。只要我们知道在哪里找到第一个节点（包含第一个项），之后的每个项可以通过连续跟随下一个链接找到。考虑到这一点，UnorderedList 类必须保持对第一个节点的引用。Listing 2 显示了构造函数。注意，每个链表对象将维护对链表头部的单个引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedList</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>我们构建一个空的链表。赋值语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mylist = UnorderedList()</span><br></pre></td></tr></table></figure>

<p>创建如 Figure 5 所示的链表。正如我们在 Node 类中讨论的，特殊引用 None 将再次用于表示链表的头部不引用任何内容。最终，先前给出的示例列表如 Figure 6 所示的链接列表表示。链表的头指代列表的第一项的第一节点。反过来，该节点保存对下一个节点（下一个项）的引用，等等。重要的是注意链表类本身不包含任何节点对象。相反，它只包含对链接结构中第一个节点的单个引用。</p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure5.png" alt="3.21.实现无序列表：链表.figure5"></p>
<p><em>Figure 5</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure6.png" alt="3.21.实现无序列表：链表.figure6"></p>
<p><em>Figure 6</em></p>
<p>Listing 3 中所示的 isEmpty 方法只是检查链表头是否是 None 的引用。 布尔表达式 self.head &#x3D;&#x3D; None 的结果只有在链表中没有节点时才为真。由于新链表为空，因此构造函数和空检查必须彼此一致。这显示了使用引用 None 来表示链接结构的 <code>end</code> 的优点。在 Python 中，None 可以与任何引用进行比较。如果它们都指向相同的对象，则两个引用是相等的。我们将在其他方法中经常使用它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.head == <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>那么，我们如何将项加入我们的链表？我们需要实现 add 方法。然而，在我们做这一点之前，我们需要解决在链表中哪个位置放置新项的重要问题。由于该链表是无序的，所以新项相对于已经在列表中的其他项的特定位置并不重要。 新项可以在任何位置。考虑到这一点，将新项放在最简单的位置是有意义的。</p>
<p>回想一下，链表结构只为我们提供了一个入口点，即链表的头部。所有其他节点只能通过访问第一个节点，然后跟随下一个链接到达。这意味着添加新节点的最简单的地方就在链表的头部。 换句话说，我们将新项作为链表的第一项，现有项将需要链接到这个新项后。</p>
<p>Figure 6 展示了链表调用多次 add 函数的操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mylist.add(31)</span><br><span class="line">&gt;&gt;&gt; mylist.add(77)</span><br><span class="line">&gt;&gt;&gt; mylist.add(17)</span><br><span class="line">&gt;&gt;&gt; mylist.add(93)</span><br><span class="line">&gt;&gt;&gt; mylist.add(26)</span><br><span class="line">&gt;&gt;&gt; mylist.add(54)</span><br></pre></td></tr></table></figure>

<p><em>Figure 6</em></p>
<p>因为 31 是添加到链表的第一个项，它最终将是链表中的最后一个节点，因为每个其他项在其前面添加。此外，由于 54 是添加的最后一项，它将成为链表的第一个节点中的数据值。</p>
<p>add 方法如 Listing 4 所示。链表的每项必须驻留在节点对象中。第 2 行创建一个新节点并将该项作为其数据。现在我们必须通过将新节点链接到现有结构中来完成该过程。这需要两个步骤，如 Figure 7 所示。步骤1（行3）更改新节点的下一个引用以引用旧链表的第一个节点。现在，链表的其余部分已经正确地附加到新节点，我们可以修改链表的头以引用新节点。第 4 行中的赋值语句设置列表的头。</p>
<p>上述两个步骤的顺序非常重要。如果第 3 行和第 4 行的顺序颠倒，会发生什么？如果链表头部的修改首先发生，则结果可以在 Figure 8 中看到。由于 head 是链表节点的唯一外部引用，所有原始节点都将丢失并且不能再被访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,item</span>):</span><br><span class="line">    temp = Node(item)</span><br><span class="line">    temp.setNext(self.head)</span><br><span class="line">    self.head = temp</span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure7.png" alt="3.21.实现无序列表：链表.figure7"></p>
<p><em>Figure 7</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure8.png" alt="3.21.实现无序列表：链表.figure8"></p>
<p><em>Figure 8</em></p>
<p>我们将实现的下面的方法 - <code>size</code>，<code>search</code> 和 <code>remove</code> - 都基于一种称为链表遍历的技术。遍历是指系统地访问每个节点的过程。为此，我们使用从链表中第一个节点开始的外部引用。当我们访问每个节点时，我们通过“遍历”下一个引用来移动到对下一个节点的引用。</p>
<p>要实现 <code>size</code> 方法，我们需要遍历链表并对节点数计数。Listing 5 展示了用于计算列表中节点数的 Python 代码。外部引用称为 <code>current</code>，并在第二行被初始化到链表的头部。开始的时候，我们没有看到任何节点，所以计数设置为 0 。第 4-6 行实际上实现了遍历。只要当前引用没到链表的结束位置（None），我们通过第 6 行中的赋值语句将当前元素移动到下一个节点。再次，将引用与 None 进行比较的能力是非常有用的。每当 <code>current</code> 移动到一个新的节点，我们加 1 以计数。最后，<code>count</code> 在迭代停止后返回。Figure 9 展示了处理这个链表的过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">    current = self.head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        current = current.getNext()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p><em>Listing 5</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure9.png" alt="3.21.实现无序列表：链表.figure9"></p>
<p><em>Figure 9</em></p>
<p>在链表中搜索也使用遍历技术。当我们访问链表中的每个节点时，我们将询问存储在其中的数据是否与我们正在寻找的项匹配。然而，在这种情况下，我们不必一直遍历到列表的末尾。事实上，如果我们到达链表的末尾，这意味着我们正在寻找的项不存在。此外，如果我们找到项，没有必要继续。</p>
<p>Listing 6 展示了搜索方法的实现。和在 <code>size</code> 方法中一样，遍历从列表的头部开始初始化（行2）。我们还使用一个布尔变量叫 <code>found</code>，标记我们是否找到了正在寻找的项。因为我们还没有在遍历开始时找到该项，<code>found</code> 设置为 False（第3行）。第4行中的迭代考虑了上述两个条件。只要有更多的节点访问，而且我们没有找到正在寻找的项，我们就继续检查下一个节点。第 5 行检查数据项是否存在于当前节点中。如果存在，<code>found</code> 设置为 True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,item</span>):</span><br><span class="line">    current = self.head</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = current.getNext()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<p><em>Listing 6</em></p>
<p>作为一个例子，试试调用 <code>search</code> 方法来查找 item 17</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mylist.search(17)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>因为 17 在列表中，所以遍历过程需要移动到包含 17 的节点。此时，<code>found</code> 变量设置为 True，while 条件将失败，返回值。 这个过程可以在 Figure 10中看到。</p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure10.png" alt="3.21.实现无序列表：链表.figure10"></p>
<p><em>Figure 10</em></p>
<p><code>remove</code> 方法需要两个逻辑步骤。首先，我们需要遍历列表寻找我们要删除的项。一旦我们找到该项（我们假设它存在），删除它。第一步非常类似于搜索。从设置到链表头部的外部引用开始，我们遍历链接，直到我们发现正在寻找的项。因为我们假设项存在，我们知道迭代将在 <code>current</code> 变为 <code>None</code> 之前停止。这意味着我们可以简单地使用 <code>found</code> 布尔值。</p>
<p>当 <code>found</code> 变为 True 时，<code>current</code> 将是对包含要删除的项的节点的引用。但是我们如何删除呢？一种方法是用标示该项目不再存在的某个标记来替换项目的值。这种方法的问题是节点数量将不再匹配项数量。最好通过删除整个节点来删除该项。</p>
<p>为了删除包含项的节点，我们需要修改上一个节点中的链接，以便它指向当前之后的节点。不幸的是，链表遍历没法回退。因为 <code>current</code> 指我们想要进行改变的节点之前的节点，所以进行修改太迟了。</p>
<p>这个困境的解决方案是在我们遍历链表时使用两个外部引用。<code>current</code> 将像之前一样工作，标记遍历的当前位置。新的引用，我们叫 <code>previous</code>，将总是传递 <code>current</code>后面的一个节点 。这样，当 <code>current</code> 停止在要被去除的节点时，<code>previous</code> 将引用链表中用于修改的位置。</p>
<p>Listing 7 展示了完整的 <code>remove</code> 方法。第 2-3 行给这两个引用赋初始值。注意，<code>current</code> 在链表头处开始，和在其他遍历示例中一样。然而，<code>previous</code> 假定总是在 <code>current</code>之后一个节点。因此，由于在 <code>previous</code> 之前没有节点，所以之前的值将为 None（见 Figure 11）。<code>found</code> 的布尔变量将再次用于控制迭代。</p>
<p>在第 6-7 行中，我们检查存储在当前节点中的项是否是我们希望删除的项。如果是，<code>found</code> 设置为 True 。如果我们没有找到该项，则 <code>previous</code> 和 <code>current</code> 都必须向前移动一个节点。同样，这两个语句的顺序是至关重要的。<code>previous</code> 必须先将一个节点移动到 <code>current</code> 的位置。此时，才可以移动<code>current</code>。这个过程通常被称为“英寸蠕动”，因为 <code>previous</code> 必须赶上 <code>current</code>，然后 <code>current</code> 前进。Figure 12 展示了 <code>previous</code> 和<code>current</code> 的移动，它们沿着链表向下移动，寻找包含值 17 的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,item</span>):</span><br><span class="line">    current = self.head</span><br><span class="line">    previous = <span class="literal">None</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line">        <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.getNext()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> previous == <span class="literal">None</span>:</span><br><span class="line">        self.head = current.getNext()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure>

<p><em>Listing 7</em></p>
<p> <img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure11.png" alt="3.21.实现无序列表：链表.figure11"></p>
<p><em>Figure 11</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure12.png" alt="3.21.实现无序列表：链表.figure12"></p>
<p><em>Figure 12</em></p>
<p>一旦 <code>remove</code> 的搜索步骤已经完成，我们需要从链表中删除该节点。 Figure 13 展示了要修改的链接。但是，有一个特殊情况需要解决。 如果要删除的项目恰好是链表中的第一个项，则 <code>current</code> 将引用链接列表中的第一个节点。这也意味着 <code>previous</code> 是 None。 我们先前说过，<code>previous</code> 是一个节点，它的下一个节点需要修改。在这种情况下，不是 <code>previous</code> ，而是链表的 <code>head</code> 需要改变（见 Figure 14）。</p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure13.png" alt="3.21.实现无序列表：链表.figure13"></p>
<p><em>Figure 13</em></p>
<p><img src="/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure14.png" alt="3.21.实现无序列表：链表.figure14"></p>
<p><em>Figure 14</em></p>
<p>第 12 行检查是否处理上述的特殊情况。如果 <code>previous</code> 没有移动，当 <code>found</code> 的布尔变为 True 时，它仍是 None。 在这种情况下（行13），链表的 <code>head</code> 被修改以指代当前节点之后的节点，实际上是从链表中移除第一节点。 但是，如果 <code>previous</code> 不为 None，则要删除的节点位于链表结构的下方。 在这种情况下，<code>previous</code> 的引用为我们提供了下一个引用更改的节点。第 15 行使用之前的 <code>setNext</code> 方法完成删除。注意，在这两种情况下，引用更改的目标是 <code>current.getNext()</code>。 经常出现的一个问题是，这里给出的两种情况是否也将处理要移除的项在链表的最后节点中的情况。我们留给你思考。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/README/" data-id="clxzhp6jq000r1s8j6l5v9wjp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.20.无序列表抽象数据类型/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.20.%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.557Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-20-无序列表抽象数据类型"><a href="#3-20-无序列表抽象数据类型" class="headerlink" title="3.20.无序列表抽象数据类型"></a>3.20.无序列表抽象数据类型</h2><p>如上所述，无序列表的结构是项的集合，其中每个项保持相对于其他项的相对位置。下面给出了一些可能的无序列表操作。</p>
<ul>
<li>List() 创建一个新的空列表。它不需要参数，并返回一个空列表。</li>
<li>add(item) 向列表中添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</li>
<li>remove(item) 从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li>
<li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li>
<li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li>
<li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li>
<li>append(item) 将一个新项添加到列表的末尾，使其成为集合中的最后一项。它需要 item 作为参数，并不返回任何内容。假定该项不在列表中。</li>
<li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li>
<li>insert(pos，item) 在位置 pos 处向列表中添加一个新项。它需要 item 作为参数并不返回任何内容。假设该项不在列表中，并且有足够的现有项使其有 pos 的位置。</li>
<li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li>
<li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.20.%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" data-id="clxzhp6jr000u1s8jg7jy4d6x" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.9.%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.8.%E6%9E%84%E5%BB%BA%E5%AD%97%E6%A2%AF%E5%9B%BE/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.7.%E5%AD%97%E6%A2%AF%E7%9A%84%E9%97%AE%E9%A2%98/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.6.%E5%AE%9E%E7%8E%B0/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.5.%E9%82%BB%E6%8E%A5%E8%A1%A8/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FLITl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>