<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FLITl的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些感想，一些技术，一些生活。">
<meta property="og:type" content="website">
<meta property="og:title" content="FLITl的博客">
<meta property="og:url" content="http://jackfrued.top/page/9/index.html">
<meta property="og:site_name" content="FLITl的博客">
<meta property="og:description" content="一些感想，一些技术，一些生活。">
<meta property="og:locale">
<meta property="article:author" content="FLITl">
<meta property="article:tag" content="反思，技术，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FLITl的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FLITl的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天命之谓性；率性之谓道；修道之谓教。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jackfrued.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.2.什么是线性数据结构/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.553Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-2-什么是线性数据结构"><a href="#3-2-什么是线性数据结构" class="headerlink" title="3.2.什么是线性数据结构"></a>3.2.什么是线性数据结构</h2><p>我们从四个简单但重要的概念开始研究数据结构。栈，队列，deques, 列表是一类数据的容器，它们数据项之间的顺序由添加或删除的顺序决定。一旦一个数据项被添加，它相对于前后元素一直保持该位置不变。诸如此类的数据结构被称为线性数据结构。</p>
<p>线性数据结构有两端，有时被称为左右，某些情况被称为前后。你也可以称为顶部和底部，名字都不重要。将两个线性数据结构区分开的方法是添加和移除项的方式，特别是添加和移除项的位置。例如一些结构允许从一端添加项，另一些允许从另一端移除项。</p>
<p>这些变种的形式产生了计算机科学最有用的数据结构。他们出现在各种算法中，并可以用于解决很多重要的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/README/" data-id="clxzhp6jq000s1s8j02h8hezx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.19.列表/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.19.%E5%88%97%E8%A1%A8/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.549Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-19-列表"><a href="#3-19-列表" class="headerlink" title="3.19.列表"></a>3.19.列表</h2><p>在对基本数据结构的讨论中，我们使用 Python 列表来实现所呈现的抽象数据类型。列表是一个强大但简单的收集机制，为程序员提供了各种各样的操作。然而，不是所有的编程语言都包括列表集合。在这些情况下，列表的概念必须由程序员实现。</p>
<p>列表是项的集合，其中每个项保持相对于其他项的相对位置。更具体地，我们将这种类型的列表称为无序列表。我们可以将列表视为具有第一项，第二项，第三项等等。我们还可以引用列表的开头（第一个项）或列表的结尾（最后一个项）。为了简单起见，我们假设列表不能包含重复项。</p>
<p>例如，整数 <code>54,26,93,17,77</code> 和 <code>31</code> 的集合可以表示考试分数的简单无序列表。请注意，我们将它们用逗号分隔，这是列表结构的常用方式。当然，Python 会显示这个列表为 <code>[54,26,93,17,77,31]</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.19.%E5%88%97%E8%A1%A8/README/" data-id="clxzhp6jp000o1s8j40nsbqzp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.18.回文检查/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.542Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-18-回文检查"><a href="#3-18-回文检查" class="headerlink" title="3.18.回文检查"></a>3.18.回文检查</h2><p>使用 deque 数据结构可以容易地解决经典回文问题。回文是一个字符串，读取首尾相同的字符，例如，<code>radar toot madam</code>。 我们想构造一个算法输入一个字符串，并检查它是否是一个回文。</p>
<p>该问题的解决方案将使用 deque 来存储字符串的字符。我们从左到右处理字符串，并将每个字符添加到 deque 的尾部。在这一点上，deque 像一个普通的队列。然而，我们现在可以利用 deque 的双重功能。 deque 的首部保存字符串的第一个字符，deque 的尾部保存最后一个字符（见 Figure 2）。</p>
<p><img src="/assets/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5.figure2.png" alt="3.18.回文检查.figure2"></p>
<p><em>Figure 2</em></p>
<p>我们可以直接删除并比较首尾字符，只有当它们匹配时才继续。如果可以持续匹配首尾字符，我们最终要么用完字符，要么留出大小为 1 的deque，取决于原始字符串的长度是偶数还是奇数。在任一情况下，字符串都是回文。 回文检查的完整功能在 ActiveCode 1 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.deque <span class="keyword">import</span> Deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palchecker</span>(<span class="params">aString</span>):</span><br><span class="line">    chardeque = Deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> aString:</span><br><span class="line">        chardeque.addRear(ch)</span><br><span class="line"></span><br><span class="line">    stillEqual = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> chardeque.size() &gt; <span class="number">1</span> <span class="keyword">and</span> stillEqual:</span><br><span class="line">        first = chardeque.removeFront()</span><br><span class="line">        last = chardeque.removeRear()</span><br><span class="line">        <span class="keyword">if</span> first != last:</span><br><span class="line">            stillEqual = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stillEqual</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(palchecker(<span class="string">&quot;lsdkjfskf&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(palchecker(<span class="string">&quot;radar&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5/README/" data-id="clxzhp6jp000m1s8je90tgujt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.17.Python实现Deque/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.17.Python%E5%AE%9E%E7%8E%B0Deque/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.537Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-17-Python实现Deque"><a href="#3-17-Python实现Deque" class="headerlink" title="3.17.Python实现Deque"></a>3.17.Python实现Deque</h2><p>正如我们在前面的部分中所做的，我们将为抽象数据类型 deque 的实现创建一个新类。同样，Python 列表将提供一组非常好的方法来构建 deque 的细节。我们的实现（Listing 1）将假定 deque 的尾部在列表中的位置为 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addFront</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addRear</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>在 removeFront 中，我们使用 pop 方法从列表中删除最后一个元素。 但是，在removeRear中，pop(0)方法必须删除列表的第一个元素。同样，我们需要在 addRear 中使用insert方法（第12行），因为 append 方法在列表的末尾添加一个新元素。</p>
<p>你可以看到许多与栈和队列中描述的 Python 代码相似之处。你也可能观察到，在这个实现中，从前面添加和删除项是 $$O(1)$$，而从后面添加和删除是 $$O(n)$$。 考虑到添加和删除项是出现的常见操作，这是可预期的。 同样，重要的是要确定我们知道在实现中前后都分配在哪里。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.17.Python%E5%AE%9E%E7%8E%B0Deque/README/" data-id="clxzhp6jo000l1s8j1q1yen88" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.16.Deque抽象数据类型/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.531Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-16-Deque抽象数据类型"><a href="#3-16-Deque抽象数据类型" class="headerlink" title="3.16.Deque抽象数据类型"></a>3.16.Deque抽象数据类型</h2><p>deque 抽象数据类型由以下结构和操作定义。如上所述，deque 被构造为项的有序集合，其中项从首部或尾部的任一端添加和移除。下面给出了 deque 操作。</p>
<ul>
<li>Deque() 创建一个空的新 deque。它不需要参数，并返回空的 deque。</li>
<li>addFront(item) 将一个新项添加到 deque 的首部。它需要 item 参数 并不返回任何内容。</li>
<li>addRear(item) 将一个新项添加到 deque 的尾部。它需要 item 参数并不返回任何内容。</li>
<li>removeFront() 从 deque 中删除首项。它不需要参数并返回 item。deque 被修改。</li>
<li>removeRear() 从 deque 中删除尾项。它不需要参数并返回 item。deque 被修改。</li>
<li>isEmpty() 测试 deque 是否为空。它不需要参数，并返回布尔值。</li>
<li>size() 返回 deque 中的项数。它不需要参数，并返回一个整数。</li>
</ul>
<p>例如，我们假设 d 是已经创建并且当前为空的 deque，则 Table 1 展示了一系列 deque 操作的结果。注意，首部的内容列在右边。在将 item 移入和移出时，跟踪前面和后面是非常重要的，因为可能会有点混乱。</p>
<p><img src="/assets/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="3.16.Deque抽象数据类型.table1"></p>
<p><em>Table 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" data-id="clxzhp6jq000q1s8j4mvv36w1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.15.什么是Deque/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.523Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-15-什么是Deque"><a href="#3-15-什么是Deque" class="headerlink" title="3.15.什么是Deque"></a>3.15.什么是Deque</h2><p>deque（也称为双端队列）是与队列类似的项的有序集合。它有两个端部，首部和尾部，并且项在集合中保持不变。deque 不同的地方是添加和删除项是非限制性的。可以在前面或后面添加新项。同样，可以从任一端移除现有项。在某种意义上，这种混合线性结构提供了单个数据结构中的栈和队列的所有能力。 Figure 1 展示了一个 Python 数据对象的 deque 。</p>
<p>要注意，即使 deque 可以拥有栈和队列的许多特性，它不需要由那些数据结构强制的 LIFO 和 FIFO 排序。这取决于你如何持续添加和删除操作。</p>
<p><img src="/assets/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque.figure1-1.png" alt="3.15.什么是Deque.figure1"></p>
<p><em>Figure 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque/README/" data-id="clxzhp6jn000k1s8j4qyvb95i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.14.模拟：打印机/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.514Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-14-模拟：打印机"><a href="#3-14-模拟：打印机" class="headerlink" title="3.14.模拟：打印机"></a>3.14.模拟：打印机</h2><p>一个更有趣的模拟是允许我们研究本节前面描述的打印机的行为，回想一下，当学生向共享打印机发送打印任务时，任务被放置在队列中以便以先来先服务的方式被处理。此配置会出现许多问题。其中最重要的点可能是打印机是否能够处理一定量的工作。如果它不能，学生将等待太长时间打印，可能会错过他们的下一节课。</p>
<p>在计算机科学实验室里考虑下面的情况。平均每天大约10名学生在任何给定时间在实验室工作。这些学生通常在此期间打印两次，这些任务的长度范围从1到20页。实验室中的打印机较旧，每分钟以草稿质量可以处理10页。打印机可以切换以提供更好的质量，但是它将每分钟只能处理五页。较慢的打印速度可能会使学生等待太久。应使用什么页面速率？</p>
<p>我们可以通过建立一个模拟实验来决定。我们将需要为学生，打印任务和打印机构建表现表示（Figure 4）。当学生提交打印任务时，我们将把他们添加到等待列表中，一个打印任务的队列。 当打印机完成任务时，它将检查队列，以检查是否有剩余的任务要处理。我们感兴趣的是学生等待他们的论文打印的平均时间。这等于任务在队列中等待的平均时间量。</p>
<p><img src="/assets/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA.figure4.png" alt="3.14.模拟：打印机.figure4"></p>
<p><em>Figure 4</em></p>
<p>为了为这种情况建模，我们需要使用一些概率。例如，学生可以打印长度从 1 到 20 页的纸张。如果从 1 到 20 的每个长度有同样的可能性，则可以通过使用 1 和 20 之间的随机数来模拟打印任务的实际长度。这意味着出现从 1 到 20 的任何长度的机会是平等的。</p>
<p>如果实验室中有 10 个学生，每人打印两次，则平均每小时有 20 个打印任务。 在任何给定的秒，打印任务将被创建的机会是什么？ 回答这个问题的方法是考虑任务与时间的比率。每小时 20 个任务意味着平均每 180 秒将有一个任务：</p>
<p><img src="/assets/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA.figure1.png" alt="3.14.模拟：打印机.figure1"></p>
<p>对于每一秒，我们可以通过生成 1 到 180 之间的随机数来模拟打印任务发生的机会。如果数字是 180，我们说一个任务已经创建。请注意，可能会在一下子创建许多任务，或者需要等待一段时间才有任务。这就是模拟的本质。你想模拟真实的情况就需要尽可能接近一般参数。</p>
<h3 id="3-14-1-主要模拟步骤"><a href="#3-14-1-主要模拟步骤" class="headerlink" title="3.14.1.主要模拟步骤"></a>3.14.1.主要模拟步骤</h3><ol>
<li><p>创建打印任务的队列，每个任务都有个时间戳。队列启动的时候为空。</p>
</li>
<li><p>每秒（currentSecond）：</p>
<ul>
<li>是否创建新的打印任务？如果是，将 <code>currentSecond</code> 作为时间戳添加到队列。</li>
<li>如果打印机不忙并且有任务在等待<ul>
<li>从打印机队列中删除一个任务并将其分配给打印机</li>
<li>从 <code>currentSecond</code> 中减去时间戳，以计算该任务的等待时间。</li>
<li>将该任务的等待时间附件到列表中稍后处理。</li>
<li>根据打印任务的页数，确定需要多少时间。</li>
</ul>
</li>
<li>打印机需要一秒打印，所以得从该任务的所需的等待时间减去一秒。</li>
<li>如果任务已经完成，换句话说，所需的时间已经达到零，打印机空闲。</li>
</ul>
</li>
<li><p>模拟完成后，从生成的等待时间列表中计算平均等待时间。</p>
</li>
</ol>
<h3 id="3-14-2-Python-实现"><a href="#3-14-2-Python-实现" class="headerlink" title="3.14.2 Python 实现"></a>3.14.2 Python 实现</h3><p>为了设计此模拟，我们将为上述三个真实世界对象创建类：<code>Printer</code>, <code>Task</code>, <code>PrintQueue</code></p>
<p><code>Printer</code> 类（Listing 2）需要跟踪它当前是否有任务。如果有，则它处于忙碌状态（13-17 行），并且可以从任务的页数计算所需的时间。构造函数允许初始化每分钟页面的配置，<code>tick</code> 方法将内部定时器递减直到打印机设置为空闲(11 行)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ppm</span>):</span><br><span class="line">        self.pagerate = ppm</span><br><span class="line">        self.currentTask = <span class="literal">None</span></span><br><span class="line">        self.timeRemaining = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.currentTask != <span class="literal">None</span>:</span><br><span class="line">            self.timeRemaining = self.timeRemaining - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.timeRemaining &lt;= <span class="number">0</span>:</span><br><span class="line">                self.currentTask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">busy</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.currentTask != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startNext</span>(<span class="params">self,newtask</span>):</span><br><span class="line">        self.currentTask = newtask</span><br><span class="line">        self.timeRemaining = newtask.getPages() * <span class="number">60</span>/self.pagerate</span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p><code>Task</code> 类（Listing 3）表示单个打印任务。创建任务时，随机数生成器将提供 1 到 20 页的长度。我们选择使用随机模块中的 <code>randrange</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">1</span>,<span class="number">21</span>)</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">1</span>,<span class="number">21</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>每个任务还需要保存一个时间戳用于计算等待时间。此时间戳将表示任务被创建并放置到打印机队列中的时间。可以使用 <code>waitTime</code> 方法来检索在打印开始之前队列中花费的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,time</span>):</span><br><span class="line">        self.timestamp = time</span><br><span class="line">        self.pages = random.randrange(<span class="number">1</span>,<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getStamp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.timestamp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPages</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.pages</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waitTime</span>(<span class="params">self, currenttime</span>):</span><br><span class="line">        <span class="keyword">return</span> currenttime - self.timestamp</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>Listing 4 实现了上述算法。<code>PrintQueue</code> 对象是我们现有队列 ADT 的一个实例。<code>newPrintTask</code> 决定是否创建一个新的打印任务。我们再次选择使用随机模块的 <code>randrange</code> 函数返回 1 到 180 之间的随机整数。打印任务每 180 秒到达一次。通过从随机整数（32 行）的范围中任意选择，我们可以模拟这个随机事件。模拟功能允许我们设置打印机的总时间和每分钟的页数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulation</span>(<span class="params">numSeconds, pagesPerMinute</span>):</span><br><span class="line"></span><br><span class="line">    labprinter = Printer(pagesPerMinute)</span><br><span class="line">    printQueue = Queue()</span><br><span class="line">    waitingtimes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> currentSecond <span class="keyword">in</span> <span class="built_in">range</span>(numSeconds):</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> newPrintTask():</span><br><span class="line">         task = Task(currentSecond)</span><br><span class="line">         printQueue.enqueue(task)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">not</span> labprinter.busy()) <span class="keyword">and</span> (<span class="keyword">not</span> printQueue.isEmpty()):</span><br><span class="line">        nexttask = printQueue.dequeue()</span><br><span class="line">        waitingtimes.append(nexttask.waitTime(currentSecond))</span><br><span class="line">        labprinter.startNext(nexttask)</span><br><span class="line"></span><br><span class="line">      labprinter.tick()</span><br><span class="line"></span><br><span class="line">    averageWait=<span class="built_in">sum</span>(waitingtimes)/<span class="built_in">len</span>(waitingtimes)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Average Wait %6.2f secs %3d tasks remaining.&quot;</span>%(averageWait,printQueue.size()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newPrintTask</span>():</span><br><span class="line">    num = random.randrange(<span class="number">1</span>,<span class="number">181</span>)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">180</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    simulation(<span class="number">3600</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p>当我们运行模拟时，我们不应该担心每次的结果不同。这是由于随机数的概率性质决定的。 因为模拟的参数可以被调整，我们对调整后可能发生的趋势感兴趣。 这里有一些结果。</p>
<p>首先，我们将使用每分钟五页的页面速率运行模拟 60 分钟（3,600秒）。 此外，我们将进行 10 次独立试验。记住，因为模拟使用随机数，每次运行将返回不同的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">      simulation(3600,5)</span><br><span class="line"></span><br><span class="line">Average Wait 165.38 secs 2 tasks remaining.</span><br><span class="line">Average Wait  95.07 secs 1 tasks remaining.</span><br><span class="line">Average Wait  65.05 secs 2 tasks remaining.</span><br><span class="line">Average Wait  99.74 secs 1 tasks remaining.</span><br><span class="line">Average Wait  17.27 secs 0 tasks remaining.</span><br><span class="line">Average Wait 239.61 secs 5 tasks remaining.</span><br><span class="line">Average Wait  75.11 secs 1 tasks remaining.</span><br><span class="line">Average Wait  48.33 secs 0 tasks remaining.</span><br><span class="line">Average Wait  39.31 secs 3 tasks remaining.</span><br><span class="line">Average Wait 376.05 secs 1 tasks remaining.</span><br></pre></td></tr></table></figure>

<p>在运行 10 次实验后，我们可以看到，平均等待时间为 122.09 秒。 还可以看到平均等待时间有很大的变化，最小值为 17.27 秒，最大值为 376.05 秒。 你也可能注意到，只有两种情况所有任务都完成。</p>
<p>现在，我们将页面速率调整为每分钟 10 页，再次运行 10 次测试，页面速度更快，我们希望在一小时内完成更多的任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">      simulation(3600,10)</span><br><span class="line"></span><br><span class="line">Average Wait   1.29 secs 0 tasks remaining.</span><br><span class="line">Average Wait   7.00 secs 0 tasks remaining.</span><br><span class="line">Average Wait  28.96 secs 1 tasks remaining.</span><br><span class="line">Average Wait  13.55 secs 0 tasks remaining.</span><br><span class="line">Average Wait  12.67 secs 0 tasks remaining.</span><br><span class="line">Average Wait   6.46 secs 0 tasks remaining.</span><br><span class="line">Average Wait  22.33 secs 0 tasks remaining.</span><br><span class="line">Average Wait  12.39 secs 0 tasks remaining.</span><br><span class="line">Average Wait   7.27 secs 0 tasks remaining.</span><br><span class="line">Average Wait  18.17 secs 0 tasks remaining.</span><br></pre></td></tr></table></figure>

<h3 id="3-14-3-讨论"><a href="#3-14-3-讨论" class="headerlink" title="3.14.3.讨论"></a>3.14.3.讨论</h3><p>我们试图回答一个问题，即当前打印机是否可以处理任务负载，如果它设置为打印更好的质量，较慢的页面速率。我们采用的方法是编写一个模拟打印任务作为各种页数和到达时间的随机事件的模拟。</p>
<p>上面的输出显示，每分钟打印 5 页，平均等待时间从低的 17 秒到高的 376 秒（约 6 分钟）。使用更快的打印速率，低值为 1 秒，高值仅为 28。此外，在 10 次运行中的 8 次，每分钟 5 页，打印任务在结束时仍在队列中等待。</p>
<p>因此，我们说减慢打印机的速度以获得更好的质量可能不是一个好主意。学生们不能等待他们的论文打印完，特别是当他们需要到下一个班级。六分钟的等待时间太长了。</p>
<p>这种类型的模拟分析允许我们回答许多问题，通常被称为“如果”的问题。我们需要做的是改变模拟使用的参数，我们可以模拟任何数量。例如</p>
<ul>
<li>如果入学人数增加，平均学生人数增加 20 人 该怎么办？</li>
<li>如果是星期六，学生不需要上课怎么办？他们能负担得了吗？</li>
<li>如果平均打印任务的大小减少了，由于 Python 是一个强大的语言，程序往往要短得多？</li>
</ul>
<p>这些问题都可以通过修改上述模拟来回答。然而，重要的是要记住，模拟有效取决于构建它的假设是没问题的。关于每小时打印任务的数量和每小时的学生数量的真实数据对于构建鲁棒性的模拟是必要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA/README/" data-id="clxzhp6jp000p1s8jc3iv9g73" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.13.模拟：烫手山芋/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.503Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-13-模拟：烫手山芋"><a href="#3-13-模拟：烫手山芋" class="headerlink" title="3.13.模拟：烫手山芋"></a>3.13.模拟：烫手山芋</h2><p>队列的典型应用之一是模拟需要以 FIFO 方式管理数据的真实场景。首先，让我们看看孩子们的游戏烫手山芋，在这个游戏中（见 Figure 2），孩子们围成一个圈，并尽可能快的将一个山芋递给旁边的孩子。在某一个时间，动作结束，有山芋的孩子从圈中移除。游戏继续开始直到剩下最后一个孩子。</p>
<p><img src="/assets/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B.figure2.png" alt="3.13.模拟：烫手山芋.figure2"><br><em>Figure 2</em></p>
<p>这个游戏相当于著名的约瑟夫问题，一个一世纪著名历史学家弗拉维奥·约瑟夫斯的传奇故事。故事讲的是，他和他的 39 个战友被罗马军队包围在洞中。他们决定宁愿死，也不成为罗马人的奴隶。他们围成一个圈，其中一人被指定为第一个人，顺时针报数到第七人，就将他杀死。约瑟夫斯是一个成功的数学家，他立即想出了应该坐到哪才能成为最后一人。最后，他加入了罗马的一方，而不是杀了自己。你可以找到这个故事的不同版本，有些说是每次报数 3 个人，有人说允许最后一个人逃跑。无论如何，思想是一样的。</p>
<p>我们将模拟这个烫山芋的过程。我们的程序将输入名称列表和一个称为 num 常量用于报数。它将返回以 <code>num</code> 为单位重复报数后剩余的最后一个人的姓名。</p>
<p>为了模拟这个圈，我们使用队列（见 Figure3）。假设拿着山芋的孩子在队列的前面。当拿到山芋的时候，这个孩子将先出列再入队列，把他放在队列的最后。经过 num 次的出队入队后，前面的孩子将被永久移除队列。并且另一个周期开始，继续此过程，直到只剩下一个名字（队列的大小为 1）。</p>
<p><img src="/assets/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B.figure3.png" alt="3.13.模拟：烫手山芋.figure3"></p>
<p><em>Figure 3</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hotPotato</span>(<span class="params">namelist, num</span>):</span><br><span class="line">    simqueue = Queue()</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> namelist:</span><br><span class="line">        simqueue.enqueue(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> simqueue.size() &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            simqueue.enqueue(simqueue.dequeue())</span><br><span class="line"></span><br><span class="line">        simqueue.dequeue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> simqueue.dequeue()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hotPotato([<span class="string">&quot;Bill&quot;</span>,<span class="string">&quot;David&quot;</span>,<span class="string">&quot;Susan&quot;</span>,<span class="string">&quot;Jane&quot;</span>,<span class="string">&quot;Kent&quot;</span>,<span class="string">&quot;Brad&quot;</span>],<span class="number">7</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>Active code 1</em></p>
<p>请注意，在此示例中，计数常数的值大于列表中的名称数。这不是一个问题，因为队列像一个圈，计数会重新回到开始，直到达到计数值。另外，请注意，列表加载到队列中以使列表上的名字位于队列的前面。在这种情况下，<code>Bill</code> 是列表中的第一个项，因此他在队列的前面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B/README/" data-id="clxzhp6jn000j1s8jcq9q61pt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.12.Python实现队列/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.12.Python%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.500Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-12-Python实现队列"><a href="#3-12-Python实现队列" class="headerlink" title="3.12.Python实现队列"></a>3.12.Python实现队列</h2><p>我们为了实现队列抽象数据类型创建一个新类。和前面一样，我们将使用列表集合来作为构建队列的内部表示。</p>
<p>我们需要确定列表的哪一端作为队首，哪一端作为队尾。Listing 1 所示的实现假定队尾在列表中的位置为 0。这允许我们使用列表上的插入函数向队尾添加新元素。弹出操作可用于删除队首的元素（列表的最后一个元素）。回想一下，这也意味着入队为 $$O(n)$$，出队为 $$O(1)$$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>进一步的操作这个队列产生如下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.size()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.isEmpty()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.enqueue(<span class="number">8.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.dequeue()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.dequeue()</span><br><span class="line"><span class="string">&#x27;dog&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.size()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.12.Python%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/README/" data-id="clxzhp6jn000g1s8jhumi272b" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/3.基本数据结构/3.11.队列抽象数据类型/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.493Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-11-队列抽象数据类型"><a href="#3-11-队列抽象数据类型" class="headerlink" title="3.11.队列抽象数据类型"></a>3.11.队列抽象数据类型</h2><p>队列抽象数据类型由以下结构和操作定义。如上所述，队列被构造为在队尾添加项的有序集合，并且从队首移除。队列保持 FIFO 排序属性。 队列操作如下。</p>
<ul>
<li>Queue() 创建一个空的新队列。 它不需要参数，并返回一个空队列。</li>
<li>enqueue(item) 将新项添加到队尾。 它需要 item 作为参数，并不返回任何内容。</li>
<li>dequeue() 从队首移除项。它不需要参数并返回 item。 队列被修改。</li>
<li>isEmpty() 查看队列是否为空。它不需要参数，并返回布尔值。</li>
<li>size() 返回队列中的项数。它不需要参数，并返回一个整数。</li>
</ul>
<p>作为示例，我们假设 q 是已经创建并且当前为空的队列，则 Table 1 展示了队列操作序列的结果。右边表示队首。 4 是第一个入队的项，因此它 dequeue 返回的第一个项。</p>
<p><img src="/assets/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="3.11.队列抽象数据类型.table1"></p>
<p><em>Table 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/README/" data-id="clxzhp6jn000i1s8j4m1s0t2h" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.9.%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.8.%E6%9E%84%E5%BB%BA%E5%AD%97%E6%A2%AF%E5%9B%BE/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.7.%E5%AD%97%E6%A2%AF%E7%9A%84%E9%97%AE%E9%A2%98/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.6.%E5%AE%9E%E7%8E%B0/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.5.%E9%82%BB%E6%8E%A5%E8%A1%A8/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FLITl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>