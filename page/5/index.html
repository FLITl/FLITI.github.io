<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FLITl的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些感想，一些技术，一些生活。">
<meta property="og:type" content="website">
<meta property="og:title" content="FLITl的博客">
<meta property="og:url" content="http://jackfrued.top/page/5/index.html">
<meta property="og:site_name" content="FLITl的博客">
<meta property="og:description" content="一些感想，一些技术，一些生活。">
<meta property="og:locale">
<meta property="article:author" content="FLITl">
<meta property="article:tag" content="反思，技术，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FLITl的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FLITl的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天命之谓性；率性之谓道；修道之谓教。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jackfrued.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.10.二叉堆实现/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.885Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-10-二叉堆实现"><a href="#6-10-二叉堆实现" class="headerlink" title="6.10.二叉堆实现"></a>6.10.二叉堆实现</h2><h3 id="6-10-1-结构属性"><a href="#6-10-1-结构属性" class="headerlink" title="6.10.1.结构属性"></a>6.10.1.结构属性</h3><p>为了使我们的堆有效地工作，我们将利用二叉树的对数性质来表示我们的堆。 为了保证对数性能，我们必须保持树平衡。平衡二叉树在根的左和右子树中具有大致相同数量的节点。 在我们的堆实现中，我们通过创建一个 <code>完整二叉树</code> 来保持树平衡。 一个完整的二叉树是一个树，其中每个层都有其所有的节点，除了树的最底层，从左到右填充。 Figure 1 展示了完整二叉树的示例。</p>
<p><img src="/assets/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0.figure1.png" alt="6.10.二叉堆实现.figure1"></p>
<p><em>Figure 1</em></p>
<p>完整二叉树的另一个有趣的属性是，我们可以使用单个列表来表示它。 我们不需要使用节点和引用，甚至列表的列表。因为树是完整的，父节点的左子节点（在位置 p 处）是在列表中位置 2p 中找到的节点。 类似地，父节点的右子节点在列表中的位置 2p + 1。为了找到树中任意节点的父节点，我们可以简单地使用Python 的整数除法。 假定节点在列表中的位置 n，则父节点在位置 n&#x2F;2。 Figure 2 展示了一个完整的二叉树，并给出了树的列表表示。 请注意父级和子级之间是 2p 和 2p+1 关系。 树的列表表示以及完整的结构属性允许我们仅使用几个简单的数学运算来高效地遍历一个完整的二叉树。 我们将看到，这也是我们的二叉堆的有效实现。</p>
<h3 id="6-10-2-堆的排序属性"><a href="#6-10-2-堆的排序属性" class="headerlink" title="6.10.2.堆的排序属性"></a>6.10.2.堆的排序属性</h3><p>我们用于堆中存储项的方法依赖于维护堆的排序属性。 堆的排序属性如下：在堆中，对于具有父 p 的每个节点 x，p 中的键小于或等于 x 中的键。 Figure 2 展示了具有堆顺序属性的完整二叉树。</p>
<p><img src="/assets/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0.figure2.png" alt="6.10.二叉堆实现.figure2"></p>
<p><em>Figure 2</em></p>
<h3 id="6-10-3-堆操作"><a href="#6-10-3-堆操作" class="headerlink" title="6.10.3.堆操作"></a>6.10.3.堆操作</h3><p>我们将开始实现一个二叉堆的构造函数。由于整个二叉堆可以由单个列表表示，所以构造函数将初始化列表和一个 <code>currentSize</code> 属性来跟踪堆的当前大小。 Listing 1 展示了构造函数的 Python 代码。 你会注意到，一个空的二叉堆有一个单一的零作为 <code>heapList</code> 的第一个元素，这个零只是放那里，用于以后简单的整数除法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinHeap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.heapList = [<span class="number">0</span>]</span><br><span class="line">        self.currentSize = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>我们将实现的下一个方法是 <code>insert</code> 。 将项添加到列表中最简单，最有效的方法是将项附加到列表的末尾。 它维护完整的树属性。但可能违反堆结构属性。可以编写一个方法，通过比较新添加的项与其父项，我们可以重新获得堆结构属性。 如果新添加的项小于其父项，则我们可以将项与其父项交换。 Figure 2 展示了将新添加的项替换到其在树中的适当位置所需的操作。</p>
<p><img src="/assets/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0.figure2-1.png" alt="6.10.二叉堆实现.figure2-1"></p>
<p><em>Figure 2</em></p>
<p>注意，当我们完成一个项时，我们需要恢复新添加的项和父项之间的堆属性。 我们还需保留任何兄弟节点的堆属性。当然，如果新添加的项非常小，我们可能仍需要将其交换另一上层。事实上，我们可能需要交换到树的顶部。 Listing 2 展示了 <code>percUp</code> 方法，它在树中向上遍历一个新项，因为它需要去维护堆属性。  注意，我们可以通过使用简单的整数除法来计算任意节点的父节点。 当前节点的父节点可以通过将当前节点的索引除以 2 来计算。</p>
<p>我们现在可以编写 <code>insert</code> 方法了（见 Listing 3）。 插入方法中的大部分工作都是由 <code>percUp</code> 完成的。 一旦一个新项被追加到树上，<code>percUp</code> 接管并正确定位新项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">percUp</span>(<span class="params">self,i</span>):</span><br><span class="line">    <span class="keyword">while</span> i // <span class="number">2</span> &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> self.heapList[i] &lt; self.heapList[i // <span class="number">2</span>]:</span><br><span class="line">         tmp = self.heapList[i // <span class="number">2</span>]</span><br><span class="line">         self.heapList[i // <span class="number">2</span>] = self.heapList[i]</span><br><span class="line">         self.heapList[i] = tmp</span><br><span class="line">      i = i // <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,k</span>):</span><br><span class="line">    self.heapList.append(k)</span><br><span class="line">    self.currentSize = self.currentSize + <span class="number">1</span></span><br><span class="line">    self.percUp(self.currentSize)</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>使用正确定义的 <code>insert</code> 方法，我们现在可以看 <code>delMin</code> 方法。 因为堆属性要求树的根是树中的最小项，所以找到最小项很容易。<code>delMin</code> 的难点在根被删除后恢复堆结构和堆顺序属性。 我们可以分两步恢复我们的堆。首先，我们将通过获取列表中的最后一个项并将其移动到根位置来恢复根项，保持我们的堆结构属性。 但是，我们可能已经破坏了我们的二叉堆的堆顺序属性。 第二，我们通过将新的根节点沿着树向下推到其正确位置来恢复堆顺序属性。 Figure 3展示了将新的根节点移动到堆中的正确位置所需的交换序列。</p>
<p><img src="/assets/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0.figure3.png" alt="6.10.二叉堆实现.figure3"></p>
<p><em>Figure 3</em></p>
<p>为了维护堆顺序属性，我们所需要做的是将根节点和最小的子节点交换。在初始交换之后，我们可以将节点和其子节点重复交换，直到节点被交换到正确的位置，使它小于两个子节点。树交换节点的代码可以在 Listing 4中的 <code>percDown</code>和<code>minChild</code> 方法中找到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">percDown</span>(<span class="params">self,i</span>):</span><br><span class="line">    <span class="keyword">while</span> (i * <span class="number">2</span>) &lt;= self.currentSize:</span><br><span class="line">        mc = self.minChild(i)</span><br><span class="line">        <span class="keyword">if</span> self.heapList[i] &gt; self.heapList[mc]:</span><br><span class="line">            tmp = self.heapList[i]</span><br><span class="line">            self.heapList[i] = self.heapList[mc]</span><br><span class="line">            self.heapList[mc] = tmp</span><br><span class="line">        i = mc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minChild</span>(<span class="params">self,i</span>):</span><br><span class="line">    <span class="keyword">if</span> i * <span class="number">2</span> + <span class="number">1</span> &gt; self.currentSize:</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> self.heapList[i*<span class="number">2</span>] &lt; self.heapList[i*<span class="number">2</span>+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p><code>delmin</code> 操作的代码在 Listing 5 中。注意，有难度的工作由辅助函数处理，在这种情况下是 <code>percDown</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delMin</span>(<span class="params">self</span>):</span><br><span class="line">    retval = self.heapList[<span class="number">1</span>]</span><br><span class="line">    self.heapList[<span class="number">1</span>] = self.heapList[self.currentSize]</span><br><span class="line">    self.currentSize = self.currentSize - <span class="number">1</span></span><br><span class="line">    self.heapList.pop()</span><br><span class="line">    self.percDown(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> retval</span><br></pre></td></tr></table></figure>

<p><em>Listing 5</em></p>
<p>为了完成我们对二叉堆的讨论，我们将看从一个列表构建整个堆的方法。你可能想到的第一种方法如下所示。给定一个列表，通过一次插入一个键轻松地构建一个堆。由于你从一个项的列表开始，该列表是有序的，可以使用二分查找找到正确的位置，以大约 $$O(logn)$$ 操作的成本插入下一个键。 但是，请记住，在列表中间插入项可能需要 $$O(n)$$ 操作来移动列表的其余部分，为新项腾出空间。 因此，要在堆中插入 n 个键，将需要总共 $$O(nlogn)$$ 操作。 然而，如果我们从整个列表开始，那么我们可以在 $$O(n)$$ 操作中构建整个堆。Listing 6 展示了构建整个堆的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildHeap</span>(<span class="params">self,alist</span>):</span><br><span class="line">    i = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">    self.currentSize = <span class="built_in">len</span>(alist)</span><br><span class="line">    self.heapList = [<span class="number">0</span>] + alist[:]</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>):</span><br><span class="line">        self.percDown(i)</span><br><span class="line">        i = i - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 6</em></p>
<p><img src="/assets/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0.figure4.png" alt="6.10.二叉堆实现.figure4"></p>
<p><em>Figure 4</em></p>
<p>Figure 4 展示了 <code>buildHeap</code> 方法在 <code>[9,6,5,2,3]</code> 的初始树中的节点移动到其正确位置时所做的交换。虽然我们从树的中间开始，并以我们的方式回到根节点，<code>percDown</code> 方法确保最大的子节点总是沿着树向下移动。因为堆是一个完整的二叉树，超过中途点的任何节点都将是树叶，因此没有子节点。注意，当<code>i = 1</code> 时，我们从树的根节点向下交换，因此可能需要多次交换。正如你在 Figure 4 最右边的两个树中可以看到的，首先 9 从根位置移出，但是 9 在树中向下移动一级之后，<code>percDown</code> 检查下一组子树，以确保它被推到下一层。在这种情况下，它与 3 进行第二次交换。现在 9 已经移动到树的最低层，不能进行进一步交换。将 Figure 4 所示的这一系列交换的列表与树进行比较是有用的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 2  [0, 9, 5, 6, 2, 3]</span><br><span class="line">i = 1  [0, 9, 2, 6, 5, 3]</span><br><span class="line">i = 0  [0, 2, 3, 6, 5, 9]</span><br></pre></td></tr></table></figure>

<p>完整二叉堆代码实现见 activecode 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinHeap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.heapList = [<span class="number">0</span>]</span><br><span class="line">        self.currentSize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">percUp</span>(<span class="params">self,i</span>):</span><br><span class="line">        <span class="keyword">while</span> i // <span class="number">2</span> &gt; <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">if</span> self.heapList[i] &lt; self.heapList[i // <span class="number">2</span>]:</span><br><span class="line">             tmp = self.heapList[i // <span class="number">2</span>]</span><br><span class="line">             self.heapList[i // <span class="number">2</span>] = self.heapList[i]</span><br><span class="line">             self.heapList[i] = tmp</span><br><span class="line">          i = i // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,k</span>):</span><br><span class="line">      self.heapList.append(k)</span><br><span class="line">      self.currentSize = self.currentSize + <span class="number">1</span></span><br><span class="line">      self.percUp(self.currentSize)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">percDown</span>(<span class="params">self,i</span>):</span><br><span class="line">      <span class="keyword">while</span> (i * <span class="number">2</span>) &lt;= self.currentSize:</span><br><span class="line">          mc = self.minChild(i)</span><br><span class="line">          <span class="keyword">if</span> self.heapList[i] &gt; self.heapList[mc]:</span><br><span class="line">              tmp = self.heapList[i]</span><br><span class="line">              self.heapList[i] = self.heapList[mc]</span><br><span class="line">              self.heapList[mc] = tmp</span><br><span class="line">          i = mc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minChild</span>(<span class="params">self,i</span>):</span><br><span class="line">      <span class="keyword">if</span> i * <span class="number">2</span> + <span class="number">1</span> &gt; self.currentSize:</span><br><span class="line">          <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">if</span> self.heapList[i*<span class="number">2</span>] &lt; self.heapList[i*<span class="number">2</span>+<span class="number">1</span>]:</span><br><span class="line">              <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delMin</span>(<span class="params">self</span>):</span><br><span class="line">      retval = self.heapList[<span class="number">1</span>]</span><br><span class="line">      self.heapList[<span class="number">1</span>] = self.heapList[self.currentSize]</span><br><span class="line">      self.currentSize = self.currentSize - <span class="number">1</span></span><br><span class="line">      self.heapList.pop()</span><br><span class="line">      self.percDown(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> retval</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildHeap</span>(<span class="params">self,alist</span>):</span><br><span class="line">      i = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">      self.currentSize = <span class="built_in">len</span>(alist)</span><br><span class="line">      self.heapList = [<span class="number">0</span>] + alist[:]</span><br><span class="line">      <span class="keyword">while</span> (i &gt; <span class="number">0</span>):</span><br><span class="line">          self.percDown(i)</span><br><span class="line">          i = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bh = BinHeap()</span><br><span class="line">bh.buildHeap([<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>
<p>我们可以在 $$O(n)$$ 中构建堆的断言可能看起来有点神秘，证明超出了本书的范围。 然而，理解的关键是记住 $$logn$$ 因子是从树的高度派生的。 对于<code>buildHeap</code> 中的大部分工作，树比 $$logn$$ 短。</p>
<p>基于可以从 $$O(n)$$ 时间构建堆的事实，你可以使用堆对列表在 $$O(nlogn)$$ 时间内排序，作为本章结尾的练习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.10.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0/README/" data-id="clxzhp6k0001y1s8jecrg7svn" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.1.目标/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.1.%E7%9B%AE%E6%A0%87/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.881Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-1-目标"><a href="#6-1-目标" class="headerlink" title="6.1.目标"></a>6.1.目标</h2><ul>
<li>要理解树数据结构是什么，以及如何使用它。</li>
<li>查看树如何用于实现 map 数据结构。</li>
<li>使用列表实现树。</li>
<li>使用类和引用来实现树。</li>
<li>实现树作为递归数据结构。</li>
<li>使用堆实现优先级队列。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.1.%E7%9B%AE%E6%A0%87/README/" data-id="clxzhp6k000231s8jf69iggc4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.9.插入排序/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.9.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.869Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-9-插入排序"><a href="#5-9-插入排序" class="headerlink" title="5.9.插入排序"></a>5.9.插入排序</h2><p>插入排序，尽管仍然是 $$O(n^2)$$，工作方式略有不同。它始终在列表的较低位置维护一个排序的子列表。然后将每个新项 “插入” 回先前的子列表，使得排序的子列表称为较大的一个项。Figure 4 展示了插入排序过程。 阴影项表示算法进行每次遍历时的有序子列表。</p>
<p><img src="/assets/5.9.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.figure4.png" alt="5.9.插入排序.figure4"></p>
<p><em>Figure 4</em></p>
<p>我们开始假设有一个项（位置 0 ）的列表已经被排序。在每次遍历时，对于每个项 1至 n-1，将针对已经排序的子列表中的项检查当前项。当我们回顾已经排序的子列表时，我们将那些更大的项移动到右边。 当我们到达较小的项或子列表的末尾时，可以插入当前项。</p>
<p>Figure 5 详细展示了第五次遍历。在该算法中的这一点，存在由 <code>17,26,54,77</code> 和 <code>93</code> 组成的五个项的排序子列表。我们插入 <code>31</code> 到已经排序的项。第一次与 93 比较导致 93 向右移位。 77 和 54 也移位。 当遇到 26 时，移动过程停止，并且 31 被置于开放位置。现在我们有一个六个项的排序子列表。</p>
<p><img src="/assets/5.9.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.figure5.png" alt="5.9.插入排序.figure5"></p>
<p><em>Figure 5</em></p>
<p><code>insertSort</code>（ActiveCode 1）的实现展示了 存在 n-1 个遍历以对 n 个排序。从位置 1 开始迭代并移动位置到 n-1，因为这些是需要插回到排序子列表中的项。第 8 行执行移位操作，将值向上移动到列表中的一个位置，在其后插入。请记住，这不是像以前的算法中的完全交换。</p>
<p>插入排序的最大比较次数是 n-1 个整数的总和。同样，是 $$O(n^2)$$。然而，在最好的情况下，每次通过只需要进行一次比较。这是已经排序的列表的情况。</p>
<p>关于移位和交换的一个注意事项也很重要。通常，移位操作只需要交换大约三分之一的处理工作，因为仅执行一次分配。在基准研究中，插入排序有非常好的性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">alist</span>):</span><br><span class="line">   <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(alist)):</span><br><span class="line"></span><br><span class="line">     currentvalue = alist[index]</span><br><span class="line">     position = index</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> position&gt;<span class="number">0</span> <span class="keyword">and</span> alist[position-<span class="number">1</span>]&gt;currentvalue:</span><br><span class="line">         alist[position]=alist[position-<span class="number">1</span>]</span><br><span class="line">         position = position-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">     alist[position]=currentvalue</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">insertionSort(alist)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.9.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/README/" data-id="clxzhp6k000201s8jgw6k5koo" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.8.选择排序/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.8.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.862Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-8-选择排序"><a href="#5-8-选择排序" class="headerlink" title="5.8.选择排序"></a>5.8.选择排序</h2><p>选择排序改进了冒泡排序，每次遍历列表只做一次交换。为了做到这一点，一个选择排序在他遍历时寻找最大的值，并在完成遍历后，将其放置在正确的位置。与冒泡排序一样，在第一次遍历后，最大的项在正确的地方。 第二遍后，下一个最大的就位。遍历 n-1 次排序 n 个项，因为最终项必须在第（n-1）次遍历之后。</p>
<p>Figure 3 展示了整个排序过程。在每次遍历时，选择最大的剩余项，然后放置在其适当位置。第一遍放置 93，第二遍放置 77，第三遍放置 55 等。 该函数展示在 ActiveCode 1 中。</p>
<p><img src="/assets/5.8.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.activecode1.png" alt="5.8.选择排序.activecode1"></p>
<p><em>Activecode 1</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">alist</span>):</span><br><span class="line">   <span class="keyword">for</span> fillslot <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">       positionOfMax=<span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> location <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,fillslot+<span class="number">1</span>):</span><br><span class="line">           <span class="keyword">if</span> alist[location]&gt;alist[positionOfMax]:</span><br><span class="line">               positionOfMax = location</span><br><span class="line"></span><br><span class="line">       temp = alist[fillslot]</span><br><span class="line">       alist[fillslot] = alist[positionOfMax]</span><br><span class="line">       alist[positionOfMax] = temp</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">selectionSort(alist)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可能会看到选择排序与冒泡排序有相同数量的比较，因此也是 $$O(n^2)$$。 然而，由于交换数量的减少，选择排序通常在基准研究中执行得更快。 事实上，对于我们的列表，冒泡排序有 20 次交换，而选择排序只有 8 次。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.8.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/README/" data-id="clxzhp6k000211s8jdyj4f10s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.7.冒泡排序/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.7.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.849Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-7-冒泡排序"><a href="#5-7-冒泡排序" class="headerlink" title="5.7.冒泡排序"></a>5.7.冒泡排序</h2><p>冒泡排序需要多次遍历列表。它比较相邻的项并交换那些无序的项。每次遍历列表将下一个最大的值放在其正确的位置。实质上，每个项“冒泡”到它所属的位置。</p>
<p>Figure 1 展示了冒泡排序的第一次遍历。阴影项正在比较它们是否乱序。如果在列表中有 n 个项目，则第一遍有 n-1 个项需要比较。重要的是要注意，一旦列表中的最大值是一个对的一部分，它将不断地被移动，直到遍历完成。</p>
<p><img src="/assets/5.7.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.figure1.png" alt="5.7.冒泡排序.figure1"></p>
<p><em>Figure 1</em></p>
<p>在第二次遍历的开始，现在最大的值已经在正确的位置。有 n-1 个项留下排序，意味着将有 n-2 对。由于每次通过将下一个最大值放置在适当位置，所需的遍历的总数将是 n-1。 在完成 n-1 遍之后，最小的项肯定在正确的位置，不需要进一步处理。 ActiveCode 1 显示完整的 <code>bubbleSort</code> 函数。它将列表作为参数，并根据需要交换项来修改它。</p>
<p>交换操作，有时称为 <code>swap</code>，在 Python 中与在大多数其他编程语言略有不同。通常，交换列表中的两个元素需要临时存储位置（额外的内存位置）。 代码片段如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = alist[i]</span><br><span class="line">alist[i] = alist[j]</span><br><span class="line">alist[j] = temp</span><br></pre></td></tr></table></figure>

<p>将交换列表中的第 i 项和第 j 项。没有临时存储，其中一个值将被覆盖。</p>
<p>在Python中，可以执行同时赋值。 语句 <code>a，b = b，a</code> 两个赋值语句同时完成（参见 Figure 2）。使用同时分配，交换操作可以在一个语句中完成。</p>
<p>ActiveCode 1 中的行 5-7 使用先前描述的三步过程执行 i 和第 i + 1 个项的交换。 注意，我们也可以使用同时分配来交换项目。</p>
<p><img src="/assets/5.7.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.figure2.png" alt="5.7.冒泡排序.figure2"></p>
<p><em>Figure 2</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">for</span> passnum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(passnum):</span><br><span class="line">            <span class="keyword">if</span> alist[i]&gt;alist[i+<span class="number">1</span>]:</span><br><span class="line">                temp = alist[i]</span><br><span class="line">                alist[i] = alist[i+<span class="number">1</span>]</span><br><span class="line">                alist[i+<span class="number">1</span>] = temp</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">bubbleSort(alist)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<p><em>ActiveCode 1</em></p>
<p>为了分析气泡排序，我们应该注意，不管项如何在初始列表中排列，将进行 n-1 次遍历以排序大小为 n 的列表。 Figure 1 展示了每次通过的比较次数。比较的总数是第 n-1 个整数的和。回想起来，前 n 个整数的和是 1&#x2F;2n^2 + 1&#x2F;2n。 第 n-1 个整数的和为 1&#x2F;2n^2 + 1&#x2F;2n -n，其为 1&#x2F;2n^2 - 1&#x2F;2n。 这仍然是 $$O(n^2)$$ 比较。在最好的情况下，如果列表已经排序，则不会进行交换。 但是，在最坏的情况下，每次比较都会导致交换元素。 平均来说，我们交换了一半时间。</p>
<p><img src="/assets/5.7.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.table1.png" alt="5.7.冒泡排序.table1"></p>
<p><em>Table1</em></p>
<p>冒泡排序通常被认为是最低效的排序方法，因为它必须在最终位置被知道之前交换项。 这些“浪费”的交换操作是非常昂贵的。 然而，因为冒泡排序遍历列表的整个未排序部分，它有能力做大多数排序算法不能做的事情。特别地，如果在遍历期间没有交换，则我们知道该列表已排序。 如果发现列表已排序，可以修改冒泡排序提前停止。这意味着对于只需要遍历几次列表，冒泡排序具有识别排序列表和停止的优点。 ActiveCode 2 展示了这种修改，通常称为 <code>短冒泡排序</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shortBubbleSort</span>(<span class="params">alist</span>):</span><br><span class="line">    exchanges = <span class="literal">True</span></span><br><span class="line">    passnum = <span class="built_in">len</span>(alist)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> passnum &gt; <span class="number">0</span> <span class="keyword">and</span> exchanges:</span><br><span class="line">       exchanges = <span class="literal">False</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(passnum):</span><br><span class="line">           <span class="keyword">if</span> alist[i]&gt;alist[i+<span class="number">1</span>]:</span><br><span class="line">               exchanges = <span class="literal">True</span></span><br><span class="line">               temp = alist[i]</span><br><span class="line">               alist[i] = alist[i+<span class="number">1</span>]</span><br><span class="line">               alist[i+<span class="number">1</span>] = temp</span><br><span class="line">       passnum = passnum-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">alist=[<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br><span class="line">shortBubbleSort(alist)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<p><em>Activecode 2</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.7.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/README/" data-id="clxzhp6jz001w1s8j3rj74lnz" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.6.排序/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.6.%E6%8E%92%E5%BA%8F/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.845Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-6-排序"><a href="#5-6-排序" class="headerlink" title="5.6.排序"></a>5.6.排序</h2><p>排序是以某种顺序从集合中放置元素的过程。例如，单词列表可以按字母顺序或按长度排序。城市列表可按人口，按地区或邮政编码排序。我们已经看到了许多能够从排序列表中获益的算法（回忆之前的回文例子和二分查找）。</p>
<p>有许多开发和分析的排序算法。表明排序是计算机科学的一个重要研究领域。对大量项进行排序可能需要大量的计算资源。与搜索一样，排序算法的效率与正在处理的项的数量有关。对于小集合，复杂的排序方法可能更麻烦，开销太高。另一方面，对于更大的集合，我们希望利用尽可能多的改进。在本节中，我们将讨论几种排序技术，并对它们的运行时间进行比较。</p>
<p>在分析特定算法之前，我们应该考虑可用于分析排序过程的操作。首先，必须比较两个值以查看哪个更小（或更大）。为了对集合进行排序，需要一些系统的方法来比较值，以查看是否有问题。比较的总数将是测量排序过程的最常见方法。第二，当值相对于彼此不在正确的位置时，可能需要交换它们。这种交换是一种昂贵的操作，并且交换的总数对于评估算法的整体效率也将是很重要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.6.%E6%8E%92%E5%BA%8F/README/" data-id="clxzhp6jz001u1s8j70mlg3os" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.5.Hash查找/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.812Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-5-Hash查找"><a href="#5-5-Hash查找" class="headerlink" title="5.5.Hash查找"></a>5.5.Hash查找</h2><p>在前面的部分中，我们通过利用关于项在集合中相对于彼此存储的位置的信息，改进我们的搜索算法。例如，通过知道列表是有序的，我们可以使用二分查找在对数时间中搜索。在本节中，我们将尝试进一步建立一个可以在 $$O(1)$$ 时间内搜索的数据结构。这个概念被称为 <code>Hash 查找</code>。</p>
<p>为了做到这一点，当我们在集合中查找项时，我们需要更多地了解项可能在哪里。如果每个项都在应该在的地方，那么搜索可以使用单个比较就能发现项的存在。然而，我们看到，通常不是这样的。</p>
<p><code>哈希表</code> 是以一种容易找到它们的方式存储的项的集合。哈希表的每个位置，通常称为一个槽，可以容纳一个项，并且由从 0 开始的整数值命名。例如，我们有一个名为 0 的槽，名为 1 的槽，名为 2 的槽，以上。最初，哈希表不包含项，因此每个槽都为空。我们可以通过使用列表来实现一个哈希表，每个元素初始化为<code>None</code> 。Figure 4 展示了大小 m &#x3D; 11 的哈希表。换句话说，在表中有 m 个槽，命名为 0 到 10。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure4.png" alt="5.5.Hash查找.figure4"></p>
<p><em>Figure 4</em></p>
<p>项和该项在散列表中所属的槽之间的映射被称为 <code>hash 函数</code>。 hash 函数将接收集合中的任何项，并在槽名范围内（0和 m-1之间）返回一个整数。假设我们有整数项 <code>54,26,93,17,77</code> 和 <code>31</code> 的集合。我们的第一个 hash 函数，有时被称为 <code>余数法</code> ，只需要一个项并将其除以表大小，返回剩余部分作为其散列值<code>（h(item) = item％11）</code>。 Table 4 给出了我们的示例项的所有哈希值。注意，这种余数方法（模运算）通常以某种形式存在于所有散列函数中，因为结果必须在槽名的范围内。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table4.png" alt="5.5.Hash查找.table4"></p>
<p><em>Table 4</em></p>
<p>一旦计算了哈希值，我们可以将每个项插入到指定位置的哈希表中，如 Figure 5 所示。注意，11 个插槽中的 6 个现在已被占用。这被称为负载因子，通常表示为 <code>λ=项数/表大小</code>, 在这个例子中，<code>λ = 6/11</code> 。<br><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure5.png" alt="5.5.Hash查找.figure5"></p>
<p><em>Figure 5</em></p>
<p>现在，当我们要搜索一个项时，我们只需使用哈希函数来计算项的槽名称，然后检查哈希表以查看它是否存在。该搜索操作是 $$O(1)$$，因为需要恒定的时间量来计算散列值，然后在该位置索引散列表。如果一切都正确的话，我们已经找到了一个恒定时间搜索算法。</p>
<p>你可能已经看到，只有每个项映射到哈希表中的唯一位置，这种技术才会起作用。 例如，如果项 44 是我们集合中的下一个项，则它的散列值为<code>0（44％11 == 0）</code>。 因为 77 的哈希值也是 0，我们会有一个问题。根据散列函数，两个或更多项将需要在同一槽中。这种现象被称为碰撞（它也可以被称为“冲突”）。显然，冲突使散列技术产生了问题。我们将在后面详细讨论。</p>
<h3 id="5-5-1-hash-函数"><a href="#5-5-1-hash-函数" class="headerlink" title="5.5.1.hash 函数"></a>5.5.1.hash 函数</h3><p>给定项的集合，将每个项映射到唯一槽的散列函数被称为完美散列函数。如果我们知道项和集合将永远不会改变，那么可以构造一个完美的散列函数。不幸的是，给定任意的项集合，没有系统的方法来构建完美的散列函数。幸运的是，我们不需要散列函数是完美的，仍然可以提高性能。</p>
<p>总是具有完美散列函数的一种方式是增加散列表的大小，使得可以容纳项范围中的每个可能值。这保证每个项将具有唯一的槽。虽然这对于小数目的项是实用的，但是当可能项的数目大时是不可行的。例如，如果项是九位数的社保号码，则此方法将需要大约十亿个槽。如果我们只想存储 25 名学生的数据，我们将浪费大量的内存。</p>
<p>我们的目标是创建一个散列函数，最大限度地减少冲突数，易于计算，并均匀分布在哈希表中的项。有很多常用的方法来扩展简单余数法。我们将在这里介绍其中几个。</p>
<p><code>分组求和法</code> 将项划分为相等大小的块（最后一块可能不是相等大小）。然后将这些块加在一起以求出散列值。例如，如果我们的项是电话号码 <code>436-555-4601</code>，我们将取出数字，并将它们分成2位数<code>（43,65,55,46,01）</code>。<code>43 + 65 + 55 + 46 + 01</code>，我们得到 210。我们假设哈希表有 11 个槽，那么我们需要除以 11 。在这种情况下，<code>210％11</code> 为 1，因此电话号码 <code>436-555-4601</code> 散列到槽 1 。一些分组求和法会在求和之前每隔一个反转。对于上述示例，我们得到 <code>43 + 56 + 55 + 64 + 01 = 219</code>，其给出 <code>219％11 = 10</code> 。</p>
<p>用于构造散列函数的另一数值技术被称为 <code>平方取中法</code>。我们首先对该项平方，然后提取一部分数字结果。例如，如果项是 44，我们将首先计算 <code>44^2 = 1,936</code> 。通过提取中间两个数字 <code>93</code> ，我们得到 <code>5（93％11）</code>。Table 5 展示了余数法和中间平方法下的项。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table5.png" alt="5.5.Hash查找.table5"></p>
<p><em>Table 5</em></p>
<p>我们还可以为基于字符的项（如字符串）创建哈希函数。 词 <code>cat</code> 可以被认为是 ascii 值的序列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">99</span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">97</span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">116</span><br></pre></td></tr></table></figure>

<p>然后，我们可以获取这三个 ascii 值，将它们相加，并使用余数方法获取散列值（参见 Figure 6）。 Listing 1 展示了一个名为 hash 的函数，它接收字符串和表大小 作为参数，并返回从 <code>0</code> 到 <code>tablesize-1</code> 的范围内的散列值。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure6.png" alt="5.5.Hash查找.figure6"></p>
<p><em>Figure 6</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">astring, tablesize</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(astring)):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="built_in">ord</span>(astring[pos])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>%tablesize</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>有趣的是，当使用此散列函数时，字符串总是返回相同的散列值。 为了弥补这一点，我们可以使用字符的位置作为权重。 Figure 7 展示了使用位置值作为加权因子的一种可能的方式。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure7.png" alt="5.5.Hash查找.figure7"></p>
<p><em>Figure 7</em></p>
<p>你可以思考一些其他方法来计算集合中项的散列值。重要的是要记住，哈希函数必须是高效的，以便它不会成为存储和搜索过程的主要部分。如果哈希函数太复杂，则计算槽名称的程序要比之前所述的简单地进行基本的顺序或二分搜索更耗时。 这将打破散列的目的。</p>
<h3 id="5-5-2-冲突解决"><a href="#5-5-2-冲突解决" class="headerlink" title="5.5.2.冲突解决"></a>5.5.2.冲突解决</h3><p>我们现在回到碰撞的问题。当两个项散列到同一个槽时，我们必须有一个系统的方法将第二个项放在散列表中。这个过程称为冲突解决。如前所述，如果散列函数是完美的，冲突将永远不会发生。然而，由于这通常是不可能的，所以冲突解决成为散列非常重要的部分。</p>
<p>解决冲突的一种方法是查找散列表，尝试查找到另一个空槽以保存导致冲突的项。一个简单的方法是从原始哈希值位置开始，然后以顺序方式移动槽，直到遇到第一个空槽。注意，我们可能需要回到第一个槽（循环）以查找整个散列表。这种冲突解决过程被称为开放寻址，因为它试图在散列表中找到下一个空槽或地址。通过系统地一次访问每个槽，我们执行称为线性探测的开放寻址技术。</p>
<p>Figure 8展示了在简单余数法散列函数<code>（54,26,93,17,77,31,44,55,20）</code> 下的整数项的扩展集合。上面的 Table 4 展示了原始项的哈希值。Figure 5 展示了原始内容。当我们尝试将 <code>44</code> 放入槽 0 时，发生冲突。在线性探测下，我们逐个顺序观察，直到找到位置。在这种情况下，我们找到槽 1。</p>
<p>再次，<code>55</code> 应该在槽 0 中，但是必须放置在槽 2 中，因为它是下一个开放位置。值 20 散列到槽 9 。由于槽 9 已满，我们进行线性探测。我们访问槽<code>10,0,1</code>和 <code>2</code>，最后在位置 3 找到一个空槽。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure8.png" alt="5.5.Hash查找.figure8"></p>
<p><em>Figure 8</em></p>
<p>一旦我们使用开放寻址和线性探测建立了哈希表，我们就必须使用相同的方法来搜索项。假设我们想查找项 <code>93</code> 。当我们计算哈希值时，我们得到 <code>5</code> 。查看槽 5 得到 <code>93</code>，返回 True。如果我们正在寻找 <code>20</code>， 现在哈希值为 <code>9</code>，而槽 <code>9</code> 当前项为 <code>31</code> 。我们不能简单地返回 False，因为我们知道可能存在冲突。我们现在被迫做一个顺序搜索，从位置 <code>10</code> 开始寻找，直到我们找到项 <code>20</code> 或我们找到一个空槽。</p>
<p>线性探测的缺点是聚集的趋势;项在表中聚集。这意味着如果在相同的散列值处发生很多冲突，则将通过线性探测来填充多个周边槽。这将影响正在插入的其他项，正如我们尝试添加上面的项 <code>20</code> 时看到的。必须跳过一组值为 <code>0</code> 的值，最终找到开放位置。该聚集如 Figure 9 所示。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure9.png" alt="5.5.Hash查找.figure9"></p>
<p><em>Figure 9</em></p>
<p>处理聚集的一种方式是扩展线性探测技术，使得不是顺序地查找下一个开放槽，而是跳过槽，从而更均匀地分布已经引起冲突的项。这将潜在地减少发生的聚集。 Figure 10 展示了使用 <code>加3</code> 探头进行碰撞识别时的项。 这意味着一旦发生碰撞，我们将查看第三个槽，直到找到一个空。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure10.png" alt="5.5.Hash查找.figure10"></p>
<p><em>Figure 10</em></p>
<p>在冲突后寻找另一个槽的过程叫 <code>重新散列</code>。使用简单的线性探测，rehash 函数是 <code>newhashvalue = rehash(oldhashvalue)</code>其中 <code>rehash(pos)=(pos + 1)％sizeoftable</code>。 <code>加3</code>rehash 可以定义为<code>rehash(pos)=(pos + 3)％sizeoftable</code>。一般来说，<code>rehash(pos)=(pos + skip)％sizeoftable</code>。重要的是要注意，“跳过”的大小必须使得表中的所有槽最终都被访问。否则，表的一部分将不被使用。为了确保这一点，通常建议表大小是素数。这是我们在示例中使用 11 的原因。</p>
<p>线性探测思想的一个变种称为二次探测。代替使用常量 “跳过” 值，我们使用rehash 函数，将散列值递增 <code>1，3，5，7，9，</code> 依此类推。这意味着如果第一哈希值是 <code>h</code>，则连续值是<code>h + 1，h + 4，h + 9，h + 16</code>，等等。换句话说，二次探测使用由连续完全正方形组成的跳跃。Figure 11 展示了使用此技术放置之后的示例值。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure11.png" alt="5.5.Hash查找.figure11"></p>
<p><em>Figure 11</em></p>
<p>用于处理冲突问题的替代方法是允许每个槽保持对项的集合（或链）的引用。链接允许许多项存在于哈希表中的相同位置。当发生冲突时，项仍然放在散列表的正确槽中。随着越来越多的项哈希到相同的位置，搜索集合中的项的难度增加。 Figure 12 展示了添加到使用链接解决冲突的散列表时的项。</p>
<p><img src="/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure12.png" alt="5.5.Hash查找.figure12"></p>
<p><em>Figure 12</em></p>
<p>当我们要搜索一个项时，我们使用散列函数来生成它应该在的槽。由于每个槽都有一个集合，我们使用一种搜索技术来查找该项是否存在。优点是，平均来说，每个槽中可能有更少的项，因此搜索可能更有效。我们将在本节结尾处查看散列的分析。</p>
<h3 id="5-5-3-实现-map-抽象数据类型"><a href="#5-5-3-实现-map-抽象数据类型" class="headerlink" title="5.5.3.实现 map 抽象数据类型"></a>5.5.3.实现 map 抽象数据类型</h3><p>最有用的 Python 集合之一是字典。回想一下，字典是一种关联数据类型，你可以在其中存储键-值对。该键用于查找关联的值。我们经常将这个想法称为 <code>map</code>。</p>
<p>map 抽象数据类型定义如下。该结构是键与值之间的关联的无序集合。map 中的键都是唯一的，因此键和值之间存在一对一的关系。操作如下。</p>
<ul>
<li>Map() 创建一个新的 map 。它返回一个空的 map 集合。</li>
<li>put(key，val) 向 map 中添加一个新的键值对。如果键已经在 map 中，那么用新值替换旧值。</li>
<li>get(key) 给定一个键，返回存储在 map 中的值或 None。</li>
<li>del 使用 <code>del map[key]</code> 形式的语句从 map 中删除键值对。</li>
<li>len() 返回存储在 map 中的键值对的数量。</li>
<li>in 返回 True 对于 <code>key in map</code> 语句，如果给定的键在 map 中，否则为False。</li>
</ul>
<p>字典一个很大的好处是，给定一个键，我们可以非常快速地查找相关的值。为了提供这种快速查找能力，我们需要一个支持高效搜索的实现。我们可以使用具有顺序或二分查找的列表，但是使用如上所述的哈希表将更好，因为查找哈希表中的项可以接近 $$O(1)$$ 性能。</p>
<p>在 Listing 2 中，我们使用两个列表来创建一个实现 Map 抽象数据类型的HashTable 类。一个名为 <code>slots</code> 的列表将保存键项，一个称 <code>data</code> 的并行列表将保存数据值。当我们查找一个键时，<code>data</code> 列表中的相应位置将保存相关的数据值。我们将使用前面提出的想法将键列表视为哈希表。注意，哈希表的初始大小已经被选择为 11。尽管这是任意的，但是重要的是，大小是质数，使得冲突解决算法可以尽可能高效。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.size = <span class="number">11</span></span><br><span class="line">        self.slots = [<span class="literal">None</span>] * self.size</span><br><span class="line">        self.data = [<span class="literal">None</span>] * self.size</span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>hash 函数实现简单的余数方法。冲突解决技术是 <code>加1</code> rehash 函数的线性探测。 put 函数（见 Listing 3）假定最终将有一个空槽，除非 key 已经存在于 <code>self.slots</code> 中。 它计算原始哈希值，如果该槽不为空，则迭代 rehash 函数，直到出现空槽。如果非空槽已经包含 key，则旧数据值将替换为新数据值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self,key,data</span>):</span><br><span class="line">  hashvalue = self.hashfunction(key,<span class="built_in">len</span>(self.slots))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> self.slots[hashvalue] == <span class="literal">None</span>:</span><br><span class="line">    self.slots[hashvalue] = key</span><br><span class="line">    self.data[hashvalue] = data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> self.slots[hashvalue] == key:</span><br><span class="line">      self.data[hashvalue] = data  <span class="comment">#replace</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      nextslot = self.rehash(hashvalue,<span class="built_in">len</span>(self.slots))</span><br><span class="line">      <span class="keyword">while</span> self.slots[nextslot] != <span class="literal">None</span> <span class="keyword">and</span> \</span><br><span class="line">                      self.slots[nextslot] != key:</span><br><span class="line">        nextslot = self.rehash(nextslot,<span class="built_in">len</span>(self.slots))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.slots[nextslot] == <span class="literal">None</span>:</span><br><span class="line">        self.slots[nextslot]=key</span><br><span class="line">        self.data[nextslot]=data</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        self.data[nextslot] = data <span class="comment">#replace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hashfunction</span>(<span class="params">self,key,size</span>):</span><br><span class="line">     <span class="keyword">return</span> key%size</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rehash</span>(<span class="params">self,oldhash,size</span>):</span><br><span class="line">    <span class="keyword">return</span> (oldhash+<span class="number">1</span>)%size</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>同样，get 函数（见 Listing 4）从计算初始哈希值开始。如果值不在初始槽中，则 rehash 用于定位下一个可能的位置。注意，第 15 行保证搜索将通过检查以确保我们没有返回到初始槽来终止。如果发生这种情况，我们已用尽所有可能的槽，并且项不存在。</p>
<p>HashTable 类提供了附加的字典功能。我们重载 <code>__getitem__</code> 和<code>__setitem__</code> 方法以允许使用 <code>[]</code> 访问。 这意味着一旦创建了HashTable，索引操作符将可用。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,key</span>):</span><br><span class="line">  startslot = self.hashfunction(key,<span class="built_in">len</span>(self.slots))</span><br><span class="line"></span><br><span class="line">  data = <span class="literal">None</span></span><br><span class="line">  stop = <span class="literal">False</span></span><br><span class="line">  found = <span class="literal">False</span></span><br><span class="line">  position = startslot</span><br><span class="line">  <span class="keyword">while</span> self.slots[position] != <span class="literal">None</span> <span class="keyword">and</span>  \</span><br><span class="line">                       <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">     <span class="keyword">if</span> self.slots[position] == key:</span><br><span class="line">       found = <span class="literal">True</span></span><br><span class="line">       data = self.data[position]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">       position=self.rehash(position,<span class="built_in">len</span>(self.slots))</span><br><span class="line">       <span class="keyword">if</span> position == startslot:</span><br><span class="line">           stop = <span class="literal">True</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">    <span class="keyword">return</span> self.get(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,key,data</span>):</span><br><span class="line">    self.put(key,data)</span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p>下面的会话展示了 HashTable 类的操作。首先，我们将创建一个哈希表并存储一些带有整数键和字符串数据值的项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; H=HashTable()</span><br><span class="line">&gt;&gt;&gt; H[54]=<span class="string">&quot;cat&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[26]=<span class="string">&quot;dog&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[93]=<span class="string">&quot;lion&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[17]=<span class="string">&quot;tiger&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[77]=<span class="string">&quot;bird&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[31]=<span class="string">&quot;cow&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[44]=<span class="string">&quot;goat&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[55]=<span class="string">&quot;pig&quot;</span></span><br><span class="line">&gt;&gt;&gt; H[20]=<span class="string">&quot;chicken&quot;</span></span><br><span class="line">&gt;&gt;&gt; H.slots</span><br><span class="line">[77, 44, 55, 20, 26, 93, 17, None, None, 31, 54]</span><br><span class="line">&gt;&gt;&gt; H.data</span><br><span class="line">[<span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;goat&#x27;</span>, <span class="string">&#x27;pig&#x27;</span>, <span class="string">&#x27;chicken&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;lion&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;tiger&#x27;</span>, None, None, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>接下来，我们将访问和修改哈希表中的一些项。注意，正替换键 20 的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; H[20]</span><br><span class="line"><span class="string">&#x27;chicken&#x27;</span></span><br><span class="line">&gt;&gt;&gt; H[17]</span><br><span class="line"><span class="string">&#x27;tiger&#x27;</span></span><br><span class="line">&gt;&gt;&gt; H[20]=<span class="string">&#x27;duck&#x27;</span></span><br><span class="line">&gt;&gt;&gt; H[20]</span><br><span class="line"><span class="string">&#x27;duck&#x27;</span></span><br><span class="line">&gt;&gt;&gt; H.data</span><br><span class="line">[<span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;goat&#x27;</span>, <span class="string">&#x27;pig&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;lion&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;tiger&#x27;</span>, None, None, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line">&gt;&gt; <span class="built_in">print</span>(H[99])</span><br><span class="line">None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-5-4-hash法分析"><a href="#5-5-4-hash法分析" class="headerlink" title="5.5.4.hash法分析"></a>5.5.4.hash法分析</h3><p>我们之前说过，在最好的情况下，散列将提供 $$O(1)$$，恒定时间搜索。然而，由于冲突，比较的数量通常不是那么简单。即使对散列的完整分析超出了本文的范围，我们可以陈述一些近似搜索项所需的比较数量的已知结果。</p>
<p>我们需要分析散列表的使用的最重要的信息是负载因子 λ。概念上，如果 λ 小，则碰撞的机会较低，这意味着项更可能在它们所属的槽中。如果 λ 大，意味着表正在填满，则存在越来越多的冲突。这意味着冲突解决更困难，需要更多的比较来找到一个空槽。使用链接，增加的碰撞意味着每个链上的项数量增加。</p>
<p>和以前一样，我们将有一个成功的搜索结果和不成功的。对于使用具有线性探测的开放寻址的成功搜索，平均比较数大约为<code>1/2（1 + 1/(1-λ)）</code>，不成功的搜索为 1&#x2F;2(1+(1&#x2F;1-λ)^2 ) 如果我们使用链接，则对于成功的情况，平均比较数目是 1+λ&#x2F;2，如果搜索不成功，则简单地是 λ 比较次数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/README/" data-id="clxzhp6jz001v1s8jh1g2ao6j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.4.二分查找/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.802Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-4-二分查找"><a href="#5-4-二分查找" class="headerlink" title="5.4.二分查找"></a>5.4.二分查找</h2><p>有序列表对于我们的比较是很有用的。在顺序查找中，当我们与第一个项进行比较时，如果第一个项不是我们要查找的，则最多还有 <code>n-1</code> 个项目。 二分查找从中间项开始，而不是按顺序查找列表。 如果该项是我们正在寻找的项，我们就完成了查找。 如果它不是，我们可以使用列表的有序性质来消除剩余项的一半。如果我们正在查找的项大于中间项，就可以消除中间项以及比中间项小的一半元素。如果该项在列表中，肯定在大的那半部分。</p>
<p>然后我们可以用大的半部分重复这个过程。从中间项开始，将其与我们正在寻找的内容进行比较。再次，我们找到元素或将列表分成两半，消除可能的搜索空间的另一部分。Figure 3 展示了该算法如何快速找到值 54 。完整的函数见CodeLens 3中。</p>
<p><img src="/assets/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.figure3.png" alt="5.4.二分查找.figure3"></p>
<p><em>Figure 3</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">alist, item</span>):</span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        last = <span class="built_in">len</span>(alist)-<span class="number">1</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first&lt;=last <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            midpoint = (first + last)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> alist[midpoint] == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> item &lt; alist[midpoint]:</span><br><span class="line">                    last = midpoint-<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    first = midpoint+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line"><span class="built_in">print</span>(binarySearch(testlist, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(binarySearch(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>

<p><em>CodeLens 3</em></p>
<p>在我们继续分析之前，我们应该注意到，这个算法是分而治之策略的一个很好的例子。分和治意味着我们将问题分成更小的部分，以某种方式解决更小的部分，然后重新组合整个问题以获得结果。 当我们执行列表的二分查找时，我们首先检查中间项。如果我们正在搜索的项小于中间项，我们可以简单地对原始列表的左半部分执行二分查找。同样，如果项大，我们可以执行右半部分的二分查找。 无论哪种方式，都是递归调用二分查找函数。 CodeLens 4 展示了这个递归版本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">alist, item</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(alist) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            midpoint = <span class="built_in">len</span>(alist)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> alist[midpoint]==item:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">if</span> item&lt;alist[midpoint]:</span><br><span class="line">                <span class="keyword">return</span> binarySearch(alist[:midpoint],item)</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> binarySearch(alist[midpoint+<span class="number">1</span>:],item)</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line"><span class="built_in">print</span>(binarySearch(testlist, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(binarySearch(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>

<p><em>CodeLens 4</em></p>
<h3 id="5-4-1-二分查找分析"><a href="#5-4-1-二分查找分析" class="headerlink" title="5.4.1.二分查找分析"></a>5.4.1.二分查找分析</h3><p>为了分析二分查找算法，我们需要记住，每个比较消除了大约一半的剩余项。该算法检查整个列表的最大比较数是多少？如果我们从 n 项开始，大约 n&#x2F;2 项将在第一次比较后留下。第二次比较后，会有约 n&#x2F;4。 然后 n&#x2F;8，n&#x2F;16，等等。 我们可以拆分列表多少次？ Table 3 帮助我们找到答案。</p>
<p><img src="/assets/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.table3.png" alt="5.4.二分查找.table3"></p>
<p><em>Table 3</em></p>
<p>当我们切分列表足够多次时，我们最终得到只有一个项的列表。 要么是我们正在寻找的项，要么不是。达到这一点所需的比较数是 i，当 $$\frac{n}{2^i} &#x3D; 1$$ 时。 求解 i 得出 $$i &#x3D; logn$$ 。 最大比较数相对于列表中的项是对数的。 因此，二分查找是 $$O(log n)$$。</p>
<p>还需要解决一个额外的分析问题。在上面所示的递归解中，递归调用，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binarySearch(alist[:midpoint],item)</span><br></pre></td></tr></table></figure>

<p>使用切片运算符创建列表的左半部分，然后传递到下一个调用（同样对于右半部分）。我们上面做的分析假设切片操作符是恒定时间的。然而，我们知道 Python中的 slice 运算符实际上是 $$O(k)$$。这意味着使用 slice 的二分查找将不会在严格的对数时间执行。幸运的是，这可以通过传递列表连同开始和结束索引来纠正。可以像 CodeLens 3 中所做的那样计算索引。我们将此实现作为练习。</p>
<p>即使二分查找通常比顺序查找更好，但重要的是要注意，对于小的 n 值，排序的额外成本可能不值得。事实上，我们应该经常考虑采取额外的分类工作是否使搜索获得好处。如果我们可以排序一次，然后查找多次，排序的成本就不那么重要。然而，对于大型列表，一次排序可能是非常昂贵，从一开始就执行顺序查找可能是最好的选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/README/" data-id="clxzhp6jz001x1s8j1mjj2c5j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.3.顺序查找/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.790Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-3-顺序查找"><a href="#5-3-顺序查找" class="headerlink" title="5.3.顺序查找"></a>5.3.顺序查找</h2><p>当数据项存储在诸如列表的集合中时，我们说它们具有线性或顺序关系。 每个数据项都存储在相对于其他数据项的位置。 在 Python 列表中，这些相对位置是单个项的索引值。由于这些索引值是有序的，我们可以按顺序访问它们。 这个过程产生我们的第一种搜索技术 <code>顺序查找</code>。</p>
<p>Figure 1 展示了这种搜索的工作原理。 从列表中的第一个项目开始，我们按照基本的顺序排序，简单地从一个项移动到另一个项，直到找到我们正在寻找的项或遍历完整个列表。如果我们遍历完整个列表，则说明正在搜索的项不存在。</p>
<p><img src="/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.figure1.png" alt="5.3.顺序查找.figure1"></p>
<p><em>Figure 1</em></p>
<p>该算法的 Python 实现见 CodeLens 1。该函数需要一个列表和我们正在寻找的项作为参数，并返回一个是否存在的布尔值。<code>found</code> 布尔变量初始化为 False，如果我们发现列表中的项，则赋值为 True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sequentialSearch</span>(<span class="params">alist, item</span>):</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> alist[pos] == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos = pos+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">42</span>, <span class="number">13</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(sequentialSearch(testlist, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(sequentialSearch(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>

<p><em>CodeLens 1</em></p>
<h3 id="5-3-1-顺序查找分析"><a href="#5-3-1-顺序查找分析" class="headerlink" title="5.3.1.顺序查找分析"></a>5.3.1.顺序查找分析</h3><p>为了分析搜索算法，我们需要定一个基本计算单位。回想一下，这通常是为了解决问题要重复的共同步骤。对于搜索，计算比较操作数是有意义的。每个比较都有可能找到我们正在寻找的项目。此外，我们在这里做另一个假设。项列表不以任何方式排序。项随机放置到列表中。换句话说，项在列表任何位置的概率是一样的。</p>
<p>如果项不在列表中，知道它的唯一方法是将其与存在的每个项进行比较。如果有n 个项，则顺序查找需要 n 个比较来发现项不存在。在项在列表中的情况下，分析不是那么简单。实际上有三种不同的情况可能发生。在最好的情况下，我们在列表的开头找到所需的项，只需要一个比较。在最坏的情况下，我们直到最后的比较才找到项，第 n 个比较。</p>
<p>平均情况怎么样？平均来说，我们会在列表的一半找到该项; 也就是说，我们将比较 n&#x2F;2 项。然而，回想一下，当 n 变大时，系数，无论它们是什么，在我们的近似中变得不重要，因此顺序查找的复杂度是 $$O(n)$$。Table 1 总结了这些结果。</p>
<p><img src="/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.table1.png" alt="5.3.顺序查找.table1"></p>
<p><em>Table 1</em></p>
<p>我们之前假设，我们列表中的项是随机放置的，因此在项之间没有相对顺序。如果项以某种方式排序，顺序查找会发生什么？我们能够在搜索技术中取得更好的效率吗？</p>
<p>假设项的列表按升序排列。如果我们正在寻找的项存在于列表中，它在 n 个位置中的概率依旧相同。我们仍然会有相同数量的比较来找到该项。然而，如果该项不存在，则有一些优点。Figure 2 展示了这个过程，寻找项 50。注意，项仍然按顺序进行比较直到 54。此时，我们知道一些额外的东西。不仅 54 不是我们正在寻找的项，也没有超过 54 的其他元素可以匹配到该项，因为列表是有序的。在这种情况下，算法不必继续查看所有项。它可以立即停止。 CodeLens 2 展示了顺序查找功能的这种变化。</p>
<p><img src="/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.figure2.png" alt="5.3.顺序查找.figure2"></p>
<p><em>Figure 2</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">orderedSequentialSearch</span>(<span class="params">alist, item</span>):</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(alist) <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">            <span class="keyword">if</span> alist[pos] == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[pos] &gt; item:</span><br><span class="line">                    stop = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line"><span class="built_in">print</span>(orderedSequentialSearch(testlist, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(orderedSequentialSearch(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>

<p><em>CodeLens 2</em></p>
<p>Table 2 总结了这些结果。 请注意，在最好的情况下，我们通过只查看一项会发现该项不在列表中。 平均来说，我们将只了解 n&#x2F;2 项就知道。然而，这种复杂度仍然是 $$O(n)$$。 总之，只有在我们没有找到该项的情况下，才通过对列表排序来改进顺序查找。</p>
<p><img src="/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.table2.png" alt="5.3.顺序查找.table2"></p>
<p><em>Table 2</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/README/" data-id="clxzhp6jy001t1s8j4ku563dg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/5.排序和搜索/5.2.搜索/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.2.%E6%90%9C%E7%B4%A2/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.785Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="5-2-搜索"><a href="#5-2-搜索" class="headerlink" title="5.2.搜索"></a>5.2.搜索</h2><p>我们现在把注意力转向计算中经常出现的一些问题，即搜索和排序问题。在本节中，我们将研究搜索。我们将在本章后面的章节中介绍。搜索是在项集合中查找特定项的算法过程。搜索通常对于项是否存在返回 True 或 False。有时它可能返回项被找到的地方。我们在这里将仅关注成员是否存在这个问题。</p>
<p>在 Python 中，有一个非常简单的方法来询问一个项是否在一个项列表中。我们使用 in 运算符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 15 <span class="keyword">in</span> [3,5,2,4,1]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 3 <span class="keyword">in</span> [3,5,2,4,1]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这很容易写，一个底层的操作替我们完成这个工作。事实证明，有很多不同的方法来搜索。我们在这里感兴趣的是这些算法如何工作以及它们如何相互比较。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.2.%E6%90%9C%E7%B4%A2/README/" data-id="clxzhp6jy001s1s8j3yubdrad" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.9.%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.8.%E6%9E%84%E5%BB%BA%E5%AD%97%E6%A2%AF%E5%9B%BE/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.7.%E5%AD%97%E6%A2%AF%E7%9A%84%E9%97%AE%E9%A2%98/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.6.%E5%AE%9E%E7%8E%B0/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.5.%E9%82%BB%E6%8E%A5%E8%A1%A8/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FLITl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>