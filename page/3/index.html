<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FLITl的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些感想，一些技术，一些生活。">
<meta property="og:type" content="website">
<meta property="og:title" content="FLITl的博客">
<meta property="og:url" content="http://jackfrued.top/page/3/index.html">
<meta property="og:site_name" content="FLITl的博客">
<meta property="og:description" content="一些感想，一些技术，一些生活。">
<meta property="og:locale">
<meta property="article:author" content="FLITl">
<meta property="article:tag" content="反思，技术，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FLITl的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FLITl的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天命之谓性；率性之谓道；修道之谓教。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jackfrued.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.11.骑士之旅/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.11.%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.064Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-11-骑士之旅"><a href="#7-11-骑士之旅" class="headerlink" title="7.11.骑士之旅"></a>7.11.骑士之旅</h2><p>另一个经典问题，我们可以用来说明第二个通用图算法称为 “骑士之旅”。骑士之旅图是在一个棋盘上用一个棋子当骑士玩。图的目的是找到一系列的动作，让骑士访问板上的每格一次。一个这样的序列被称为“旅游”。骑士的旅游难题已经吸引了象棋玩家，数学家和计算机科学家多年。一个 $$8 \times 8$$ 棋盘的可能的游览次数的上限为 $$1.305 \times 10^{35}$$ ;然而，还有更多可能的死胡同。显然，这是一个需要脑力，计算能力，或两者都需要的问题。</p>
<p>虽然研究人员已经研究了许多不同的算法来解决骑士的旅游问题，图搜索是最容易理解的程序之一。再次，我们将使用两个主要步骤解决问题：</p>
<ul>
<li>表示骑士在棋盘上作为图的动作。</li>
<li>使用图算法来查找长度为 $$rows \times columns-1$$ 的路径，其中图上的每个顶点都被访问一次。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.11.%E9%AA%91%E5%A3%AB%E4%B9%8B%E6%97%85/README/" data-id="clxzhp6k5002t1s8j1gxsaxp8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.10.广度优先搜索分析/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%88%86%E6%9E%90/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.059Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-10-广度优先搜索分析"><a href="#7-10-广度优先搜索分析" class="headerlink" title="7.10.广度优先搜索分析"></a>7.10.广度优先搜索分析</h2><p>在继续使用其他图算法之前，让我们分析广度优先搜索算法的运行时性能。首先要观察的是，对于图中的每个顶点 $$|V|$$ 最多执行一次 while 循环。因为一个顶点必须是白色，才能被检查和添加到队列。这给出了用于 while 循环的 $$O(V)$$。嵌套在 while 内部的 for 循环对于图中的每个边执行最多一次，$$|E|$$。原因是每个顶点最多被出列一次，并且仅当节点 u 出队时，我们才检查从节点 u 到节点 v 的边。这给出了用于 for 循环的 $$O(E)$$ 。组合这两个环路给出了 $$O(V+E)$$。</p>
<p>当然做广度优先搜索只是任务的一部分。从起始节点到目标节点的链接之后是任务的另一部分。最糟糕的情况是，如果图是单个长链。在这种情况下，遍历所有顶点将是 $$O(V)$$。正常情况将是 $$|V|$$ 的一小部分但我们仍然写 $$O(V)$$。</p>
<p>最后，至少对于这个问题，存在构建初始图形所需的时间。我们把 <code>buildGraph</code> 函数的分析作为一个练习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%88%86%E6%9E%90/README/" data-id="clxzhp6k4002m1s8j3vvfe8v1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/7.图和图的算法/7.1.目标/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.1.%E7%9B%AE%E6%A0%87/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.052Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="7-1-目标"><a href="#7-1-目标" class="headerlink" title="7.1.目标"></a>7.1.目标</h2><ul>
<li>了解图是什么，以及如何使用它。</li>
<li>使用多个内部表示来实现图抽象数据类型。</li>
<li>看看如何使用图来解决各种各样的问题</li>
</ul>
<p>在本章中，我们将研究图。图是比我们在上一章中研究的树更通用的结构;实际上你可以认为树是一种特殊的图。图可以用来表示我们世界上许多有趣的事情，包括道路系统，从城市到城市的航空公司航班，互联网如何连接，甚至是完成计算机科学专业必须完成的课程顺序。我们将在本章中看到，一旦我们有一个问题的好的表示，我们可以使用一些标准图算法来解决，否则可能是一个非常困难的问题。</p>
<p>虽然人们相对容易看路线图并且理解不同地点之间的关系，但计算机没有这样的知识。然而，我们也可以将路线图视为图。当我们这样做时，我们可以让我们的计算机为我们做有趣的事情。如果你曾经使用过一个互联网地图网站，你知道一台计算机可以找到从一个地方到另一个地方最短，最快或最简单的路径。</p>
<p>作为计算机科学的学生，你可能想知道你必须学习的课程，以获得一个学位。图是表示学该课程之前的先决条件和其他相互依存关系的好方法。Figure 1 展示了另一个图。这个代表了在路德学院完成计算机科学专业的课程和顺序。</p>
<p><img src="/assets/7.1.%E7%9B%AE%E6%A0%87.figure1.png" alt="7.1.目标.figure1"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.1.%E7%9B%AE%E6%A0%87/README/" data-id="clxzhp6k4002k1s8j21tk1byq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.9.二叉堆操作/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.9.%E4%BA%8C%E5%8F%89%E5%A0%86%E6%93%8D%E4%BD%9C/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.045Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-9-二叉堆操作"><a href="#6-9-二叉堆操作" class="headerlink" title="6.9.二叉堆操作"></a>6.9.二叉堆操作</h2><p>我们的二叉堆实现的基本操作如下：</p>
<ul>
<li>BinaryHeap() 创建一个新的，空的二叉堆。</li>
<li>insert(k) 向堆添加一个新项。</li>
<li>findMin() 返回具有最小键值的项，并将项留在堆中。</li>
<li>delMin() 返回具有最小键值的项，从堆中删除该项。</li>
<li>如果堆是空的，isEmpty() 返回 true，否则返回 false。</li>
<li>size() 返回堆中的项数。</li>
<li>buildHeap(list) 从键列表构建一个新的堆。</li>
</ul>
<p>ActiveCode 1 展示了使用一些二叉堆方法。注意，无论我们向堆中添加项的顺序是什么，每次都删除最小的。我们现在将把注意力转向如何实现这个想法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.trees.binheap <span class="keyword">import</span> BinHeap</span><br><span class="line"></span><br><span class="line">bh = BinHeap()</span><br><span class="line">bh.insert(<span class="number">5</span>)</span><br><span class="line">bh.insert(<span class="number">7</span>)</span><br><span class="line">bh.insert(<span class="number">3</span>)</span><br><span class="line">bh.insert(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bh.delMin())</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.9.%E4%BA%8C%E5%8F%89%E5%A0%86%E6%93%8D%E4%BD%9C/README/" data-id="clxzhp6k4002l1s8jf7l5dzmp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.8.基于二叉堆的优先队列/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.8.%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.040Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-8-基于二叉堆的优先队列"><a href="#6-8-基于二叉堆的优先队列" class="headerlink" title="6.8.基于二叉堆的优先队列"></a>6.8.基于二叉堆的优先队列</h2><p>在前面的部分中，你了解了称为队列的先进先出数据结构。队列的一个重要变种称为优先级队列。优先级队列的作用就像一个队列，你可以通过从前面删除一个项目来出队。然而，在优先级队列中，队列中的项的逻辑顺序由它们的优先级确定。最高优先级项在队列的前面，最低优先级的项在后面。因此，当你将项排入优先级队列时，新项可能会一直移动到前面。我们将在下一章中研究一些图算法看到优先级队列是有用的数据结构。</p>
<p>你可能想到了几种简单的方法使用排序函数和列表实现优先级队列。然而，插入列表是 $$O(n)$$ 并且排序列表是 $$O(nlogn)$$。我们可以做得更好。实现优先级队列的经典方法是使用称为二叉堆的数据结构。二叉堆将允许我们在 $$O(logn)$$ 中排队和取出队列。</p>
<p>二叉堆是很有趣的研究，因为堆看起来很像一棵树，但是当我们实现它时，我们只使用一个单一的列表作为内部表示。二叉堆有两个常见的变体：最小堆（其中最小的键总是在前面）和最大堆（其中最大的键值总是在前面）。在本节中，我们将实现最小堆。我们将最大堆实现作为练习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.8.%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/README/" data-id="clxzhp6k4002j1s8j8ce68cc4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.7.树的遍历/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.7.%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.032Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-7-树的遍历"><a href="#6-7-树的遍历" class="headerlink" title="6.7.树的遍历"></a>6.7.树的遍历</h2><p>我们已经见到了树数据结构的基本功能，现在是看树的一些额外使用模式的时候了。这些使用模式可以分为我们访问树节点的三种方式。有三种常用的模式来访问树中的所有节点。这些模式之间的差异是每个节点被访问的顺序。我们称这种访问节点方式为“遍历”。我们将看到三种遍历方式称为<code>前序，中序</code>和<code>后序</code> 。让我们更仔细地定义这三种遍历方式，然后看看这些模式有用的一些例子。</p>
<p><strong>前序</strong><br>在前序遍历中，我们首先访问根节点，然后递归地做左侧子树的前序遍历，随后是右侧子树的递归前序遍历。<br><strong>中序</strong><br>在一个中序遍历中，我们递归地对左子树进行一次遍历，访问根节点，最后递归遍历右子树。<br><strong>后序</strong><br>在后序遍历中，我们递归地对左子树和右子树进行后序遍历，然后访问根节点。</p>
<p>让我们看一些例子，来说明这三种遍历。首先看前序遍历。作为遍历的树的示例，我们将把这本书表示为树。这本书是树的根，每一章都是根节点的一个孩子。章节中的每个章节都是章节的子节点，每个小节都是章节的子节点，依此类推。Figure 5 展示了一本只有两章的书的有限版本。注意，遍历算法适用于具有任意数量子节点的树，但是我们现在使用二叉树。</p>
<p><img src="/assets/6.7.%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.figure5.png" alt="6.7.树的遍历.figure5"></p>
<p><em>Figure 5</em></p>
<p>假设你想从前到后读这本书。前序遍历给你正确的顺序。从树的根（Book节点）开始，我们将遵循前序遍历指令。我们递归调用左孩子的 <code>preorder</code>，在这种情况下是 <code>Chapter1</code>。我们再次递归调用左孩子的 <code>preorder</code> 来得到 <code>Section 1.1</code> 。由于 <code>Section 1.1</code> 没有子节点，我们不再进行任何额外的递归调用。当我们完成 <code>Section 1.1</code>，我们将树向上移动到<code>Chapter1</code>。此时，我们仍然需要访问 <code>Chapter1</code> 的右子树 <code>Section 1.2</code>。和前面一样，我们访问左子树，它将我们带到 <code>Section 1.2.1</code>，然后访问 <code>Section 1.2.2</code>。在 <code>Section 1.2</code> 完成后，我们返回到 <code>Chapter1</code>。然后，我们返回到 <code>Book</code> 节点，并按照相同过程遍历 <code>Chapter2</code>。</p>
<p>编写树遍历的代码惊人地优雅，主要是因为遍历是递归写的。Listing 2 展示了用于二叉树的前序遍历的 Python 代码。</p>
<p>你可能想知道，编写像前序遍历算法的最好方法是什么？是一个简单地使用树作为数据结构的函数，还是树数据结构本身的方法？Listing 2 展示了作为外部函数编写的前序遍历的版本，它将二叉树作为参数。外部函数特别优雅，因为我们的基本情况只是检查树是否存在。如果树参数为 None，那么函数返回而不采取任何操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        <span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">        preorder(tree.getLeftChild())</span><br><span class="line">        preorder(tree.getRightChild())</span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>我们也可以实现 <code>preorder</code> 作为 <code>BinaryTree</code> 类的方法。Listing 3 中展示了将 <code>preorder</code> 实现为内部方法的代码。注意当我们将代码从内部移动到外部时会发生什么。 一般来说，我们只需用 <code>self</code> 替换 <code>tree</code>。 但是，我们还需要修改基本情况。内部方法必须在进行前序的递归调用之前检查左和右孩子的存在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self.key)</span><br><span class="line">    <span class="keyword">if</span> self.leftChild:</span><br><span class="line">        self.leftChild.preorder()</span><br><span class="line">    <span class="keyword">if</span> self.rightChild:</span><br><span class="line">        self.rightChild.preorder()</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>以上哪种方式实现前序最好？ 答案是在这种情况下，实现前序作为外部函数可能更好。原因是你很少只是想遍历树。在大多数情况下，将要使用其中一个基本的遍历模式来完成其他任务。 事实上，我们将在下面的例子中看到后序遍历模式与我们前面编写的用于计算分析树的代码非常接近。 因此，我们用外部函数实现其余的遍历。</p>
<p>Listing 4 中所示的后序遍历算法几乎与前序遍历顺序相同，只是将 print 调用移动到函数的末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> tree != <span class="literal">None</span>:</span><br><span class="line">        postorder(tree.getLeftChild())</span><br><span class="line">        postorder(tree.getRightChild())</span><br><span class="line">        <span class="built_in">print</span>(tree.getRootVal())</span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p>我们已经看到了后序遍历的常见用法，即计算分析树。再次回到 Listing 1。 我们所做的是计算左子树，计算右子树，并通过对操作符的函数调用在根节点中组合它们。假设我们的二叉树只存储表达式树的数据，让我们重写计算函数，需要更仔细地对 Listing 4中的后序遍历代码进行建模（参见 Listing 5）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postordereval</span>(<span class="params">tree</span>):</span><br><span class="line">    opers = &#123;<span class="string">&#x27;+&#x27;</span>:operator.add, <span class="string">&#x27;-&#x27;</span>:operator.sub, <span class="string">&#x27;*&#x27;</span>:operator.mul, <span class="string">&#x27;/&#x27;</span>:operator.truediv&#125;</span><br><span class="line">    res1 = <span class="literal">None</span></span><br><span class="line">    res2 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        res1 = postordereval(tree.getLeftChild())</span><br><span class="line">        res2 = postordereval(tree.getRightChild())</span><br><span class="line">        <span class="keyword">if</span> res1 <span class="keyword">and</span> res2:</span><br><span class="line">            <span class="keyword">return</span> opers[tree.getRootVal()](res1,res2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tree.getRootVal()</span><br></pre></td></tr></table></figure>

<p><em>Listing 5</em></p>
<p>请注意，Listing 4中的形式与 Listing 5中的形式相同，只是不在函数的末尾打印值，而是返回它。 这允许我们保存从第 6 行和第 7 行的递归调用返回的值。然后，我们使用这些保存的值以及第 9 行的运算符一起计算结果。</p>
<p>在本节中我们最终将看到中序遍历。 在中序遍历中，我们访问左子树，其次是根，最后是右子树。 Listing 6 展示了我们的中序遍历的代码。 注意，在所有三个遍历函数中，我们只是改变 print 语句相对于两个递归函数调用的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">tree</span>):</span><br><span class="line">  <span class="keyword">if</span> tree != <span class="literal">None</span>:</span><br><span class="line">      inorder(tree.getLeftChild())</span><br><span class="line">      <span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">      inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure>

<p><em>Listing 6</em></p>
<p>如果我们执行一个简单的中序遍历分析树，我们得到没有任何括号的原始表达式。 让我们修改基本的 <code>inorder</code> 算法，以允许我们恢复表达式的完全括号版本。 我们将对基本模板进行的唯一修改如下：在递归调用左子树之前打印左括号，并在递归调用右子树后打印右括号。 修改后的代码如 Listing 7所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printexp</span>(<span class="params">tree</span>):</span><br><span class="line">  sVal = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> tree:</span><br><span class="line">      sVal = <span class="string">&#x27;(&#x27;</span> + printexp(tree.getLeftChild())</span><br><span class="line">      sVal = sVal + <span class="built_in">str</span>(tree.getRootVal())</span><br><span class="line">      sVal = sVal + printexp(tree.getRightChild())+<span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> sVal</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.7.%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/README/" data-id="clxzhp6k3002i1s8j23x21jbg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.6.分析树/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.6.%E5%88%86%E6%9E%90%E6%A0%91/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.012Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-6-分析树"><a href="#6-6-分析树" class="headerlink" title="6.6.分析树"></a>6.6.分析树</h2><p>随着我们的树数据结构的实现完成，我们现在看一个例子，说明如何使用树来解决一些真正的问题。在本节中，我们将讨论分析树。 分析树可以用于表示诸如句子或数学表达式的真实世界构造。</p>
<p><img src="/assets/6.6.%E5%88%86%E6%9E%90%E6%A0%91.figure1.png" alt="6.6.分析树.figure1"></p>
<p><em>Figure 1</em></p>
<p>Figure 1 展示了一个简单句子的层次结构。 将句子表示为树结构允许我们通过使用子树来处理句子的各个部分。</p>
<p><img src="/assets/6.6.%E5%88%86%E6%9E%90%E6%A0%91.figure2.png" alt="6.6.分析树.figure2"></p>
<p><em>Figure 2</em></p>
<p>我们还可以表示诸如 <code>（（7 + 3）*（5-2））</code> 数学表达式作为分析树，如 Figure 2 所示。我们早看过完全括号表达式，所以我们知道这个表达式是什么？我们知道乘法具有比加法或减法更高的优先级。由于括号，我们知道在做乘法之前，我们必须计算括号里面的加法和减法表达式。树的层次结构有助于我们了解整个表达式的求值顺序。在我们计算顶层乘法之前，我们必须计算子树中的加法和减法。作为左子树的加法结果为10。减法，即右子树，计算结果为3。使用树的层次结构，我们可以简单地用一个节点替换整个子树，一旦我们计算了表达式中这些子树。这个替换过程给出了 Figure 3 所示的简化树。</p>
<p><img src="/assets/6.6.%E5%88%86%E6%9E%90%E6%A0%91.figure3-1.png" alt="6.6.分析树.figure3"></p>
<p><em>Figure 3</em></p>
<p>在本节的其余部分，我们将更详细地检查分析树。 特别的，我们会看</p>
<ul>
<li>如何从完全括号的数学表达式构建分析树。</li>
<li>如何评估存储在分析树中的表达式。</li>
<li>如何从分析树中恢复原始数学表达式。</li>
</ul>
<p>构建分析树的第一步是将表达式字符串拆分成符号列表。 有四种不同的符号要考虑：左括号，右括号，运算符和操作数。 我们知道，每当我们读一个左括号，我们开始一个新的表达式，因此我们应该创建一个新的树来对应于该表达式。 相反，每当我们读一个右括号，我们就完成了一个表达式。 我们还知道操作数将是叶节点和它们的操作符的子节点。 最后，我们知道每个操作符都将有一个左和右孩子。</p>
<p>使用上面的信息，我们可以定义四个规则如下：</p>
<ul>
<li>如果当前符号是 <code>&#39;(&#39;</code>，添加一个新节点作为当前节点的左子节点，并下降到左子节点。</li>
<li>如果当前符号在列表 <code>[&#39;+&#39;，&#39; - &#39;，&#39;/&#39;，&#39;*&#39;]</code> 中，请将当前节点的根值设置为由当前符号表示的运算符。 添加一个新节点作为当前节点的右子节点，并下降到右子节点。</li>
<li>如果当前符号是数字，请将当前节点的根值设置为该数字并返回到父节点。</li>
<li>如果当前令牌是 <code>&#39;)&#39;</code>，则转到当前节点的父节点。</li>
</ul>
<p>在编写 Python 代码之前，让我们看看上面列出的规则的一个例子。我们将使用表达式<code>（3+（4 * 5））</code>。 我们将把这个表达式解析成下面的字符标记列表 <code>[&#39;(&#39;，&#39;3&#39;，&#39;+&#39;，&#39;(&#39;，&#39;4&#39;，&#39;*&#39;，&#39;5&#39;，&#39;)&#39;，&#39;)&#39;]</code>。 最初，我们将使用由空根节点组成的分析树开始。 Figure 4 展示了当每个新符号被处理时分析树的结构和内容。</p>
<p><img src="/assets/6.6.%E5%88%86%E6%9E%90%E6%A0%91.figure4-1.png" alt="6.6.分析树.figure4-1"></p>
<p><img src="/assets/6.6.%E5%88%86%E6%9E%90%E6%A0%91.figure4-2.png" alt="6.6.分析树.figure4-2"></p>
<p><em>Figure 4</em></p>
<p>使用 Figure 4，让我们一步一步地浏览示例：</p>
<p>a. 创建一个空树。</p>
<p>b. 读取 ( 作为第一个标记。按规则1，创建一个新节点作为根的左子节点。使当前节点到这个新子节点。</p>
<p>c. 读取 3 作为下一个符号。按照规则3，将当前节点的根值设置为3，使当前节点返回到父节点。</p>
<p>d. 读取 + 作为下一个符号。根据规则2，将当前节点的根值设置为+，并添加一个新节点作为右子节点。新的右子节点成为当前节点。</p>
<p>e. 读取 ( 作为下一个符号，按规则1，创建一个新节点作为当前节点的左子节点，新的左子节点成为当前节点。</p>
<p>f. 读取 4 作为下一个符号。根据规则3，将当前节点的值设置为 4。使当前节点返回到父节点。</p>
<p>g. 读取 * 作为下一个符号。根据规则2，将当前节点的根值设置为 * ，并创建一个新的右子节点。新的右子节点成为当前节点。</p>
<p>h. 读取 5 作为下一个符号。根据规则3，将当前节点的根值设置为5。使当前节点返回到父节点。</p>
<p>i. 读取 ) 作为下一个符号。根据规则4，使当前节点返回到父节点。</p>
<p>j. 读取 ) 作为下一个符号。根据规则4，使当前节点返回到父节点 + 。没有+ 的父节点，所以我们完成创建。</p>
<p>从上面的例子，很明显，我们需要跟踪当前节点以及当前节点的父节点。树接口为我们提供了一种通过 <code>getLeftChild</code> 和 <code>getRightChild</code> 方法获取节点的子节点的方法，但是我们如何跟踪父节点呢？当我们遍历树时，保持跟踪父对象的简单解决方案是使用栈。每当我们想下降到当前节点的子节点时，我们首先将当前节点入到栈上。当我们想要返回到当前节点的父节点时，我们将父节点从栈中弹出。</p>
<p>使用上述规则，以及 <code>Stack</code>和 <code>BinaryTree</code> 操作，我们现在可以编写一个Python 函数来创建一个分析树。我们的分析树生成器的代码见 ActiveCode 1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"><span class="keyword">from</span> pythonds.trees.binaryTree <span class="keyword">import</span> BinaryTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildParseTree</span>(<span class="params">fpexp</span>):</span><br><span class="line">    fplist = fpexp.split()</span><br><span class="line">    pStack = Stack()</span><br><span class="line">    eTree = BinaryTree(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    pStack.push(eTree)</span><br><span class="line">    currentTree = eTree</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fplist:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            currentTree.insertLeft(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            pStack.push(currentTree)</span><br><span class="line">            currentTree = currentTree.getLeftChild()</span><br><span class="line">        <span class="keyword">elif</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;)&#x27;</span>]:</span><br><span class="line">            currentTree.setRootVal(<span class="built_in">int</span>(i))</span><br><span class="line">            parent = pStack.pop()</span><br><span class="line">            currentTree = parent</span><br><span class="line">        <span class="keyword">elif</span> i <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]:</span><br><span class="line">            currentTree.setRootVal(i)</span><br><span class="line">            currentTree.insertRight(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            pStack.push(currentTree)</span><br><span class="line">            currentTree = currentTree.getRightChild()</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            currentTree = pStack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> eTree</span><br><span class="line"></span><br><span class="line">pt = buildParseTree(<span class="string">&quot;( ( 10 + 5 ) * 3 )&quot;</span>)</span><br><span class="line">pt.postorder()  <span class="comment">#defined and explained in the next section</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>Activecode1</em></p>
<p>用于构建分析树的四个规则被编码为 ActiveCode 1 的行 11,15,19 和 24 上的 if 语句的前四个子句。在每种情况下，可以看到代码实现了如上所述的规则，与几个调用 BinaryTree 或 Stack 方法。我们在这个函数中唯一的错误检查是在 else 子句中，如果我们从列表中得到一个我们不认识的 token，我们引发一个ValueError异常。</p>
<p>现在我们已经构建了一个分析树，我们可以用它做什么？作为第一个例子，我们将编写一个函数来评估分析树，返回数值结果。要写这个函数，我们将利用树的层次性。回想一下 Figure 2。我们可以用 Figure 3 中所示的简化树替换原始树。这表明我们可以编写一个算法，通过递归地评估每个子树来评估一个分析树。</p>
<p>正如我们对过去的递归算法所做的，我们将通过识别基本情况来开始递归评价函数的设计。对树进行操作的递归算法的基本情况是检查叶节点。在分析树中，叶节点将始终是操作数。由于整数和浮点等数值对象不需要进一步解释，因此 <code>evaluate</code> 函数可以简单地返回存储在叶节点中的值。将函数移向基本情况的递归步骤是在当前节点的左子节点和右子节点上调用 evaluate。递归调用有效地使我们沿着树向着叶节点移动。</p>
<p>为了将两个递归调用的结果放在一起，我们可以简单地将存储在父节点中的运算符应用于从评估这两个子节点返回的结果。在 Figure 3的示例中，我们看到根的两个孩子计算得出结果，即 10 和 3。应用乘法运算符给我们一个最终结果 30。</p>
<p>递归求值函数的代码如 Listing 1 所示。首先，我们获取对当前节点的左子节点和右子节点的引用。如果左和右孩子都为 None ，那么我们知道当前节点实际上是一个叶节点。此检查在行 7。如果当前节点不是叶节点，请查找当前节点中的运算符，并将其应用于递归计算左右子节点的结果。</p>
<p>为了实现算术，我们使用具有键 <code>&#39;+&#39;，&#39; - &#39;，&#39;*&#39;</code>和 <code>&#39;/&#39;</code> 的字典。存储在字典中的值是来自 Python 的运算符模块的函数。运算符模块为我们提供了许多常用操作符的功能。当我们在字典中查找一个运算符时，检索相应的函数对象。由于检索的对象是一个函数，我们可以用通常的方式 <code>function(param1，param2)</code> 调用它。因此，查找 <code>opers[&#39;+&#39;](2,2)</code> 等效于<code>operator.add(2,2)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">parseTree</span>):</span><br><span class="line">    opers = &#123;<span class="string">&#x27;+&#x27;</span>:operator.add, <span class="string">&#x27;-&#x27;</span>:operator.sub, <span class="string">&#x27;*&#x27;</span>:operator.mul, <span class="string">&#x27;/&#x27;</span>:operator.truediv&#125;</span><br><span class="line"></span><br><span class="line">    leftC = parseTree.getLeftChild()</span><br><span class="line">    rightC = parseTree.getRightChild()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> leftC <span class="keyword">and</span> rightC:</span><br><span class="line">        fn = opers[parseTree.getRootVal()]</span><br><span class="line">        <span class="keyword">return</span> fn(evaluate(leftC),evaluate(rightC))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> parseTree.getRootVal()</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>最后，我们将跟踪我们在 Figure 4 中创建的分析树上的求值函数。当我们首先调用 evaluate 时，我们将整个树的根作为参数 parseTree 传递。然后我们获得对左和右孩子的引用，以确保它们存在。递归调用发生在第 9 行。我们首先在树的根中查找运算符，它是<code>&#39;+&#39;</code>。 <code>&#39;+&#39;</code> 操作符映射到<code>operator.add</code>函数调用，它接受两个参数。像 Python 函数调用一样，Python 做的第一件事是计算传递给函数的参数。在这种情况下，两个参数都是对我们的 evaluate 函数的递归函数调用。使用从左到右的计算，第一个递归调用向左。在第一个递归调用中，赋值函数给出左子树。我们发现节点没有左或右孩子，所以我们得到一个叶节点。当我们在叶节点时，我们只是返回存储在叶节点中的值作为计算的结果。在这种情况下，我们返回整数 3 。</p>
<p>在这一点上，我们有一个参数对 <code>operator.add</code> 的顶层调用进行求值。但我们还没有完成。继续从左到右的参数计算，我们现在进行递归调用来评估根的右孩子。我们发现节点有一个左和右孩子，所以我们查找存储在这个节点 ‘*’ 运算符，并使用左和右孩子作为参数调用此函数。你可以看到，两个递归调用都到了叶节点，分别计算结果为整数 4 和 5。使用两个参数求值，我们返回<code>operator.mul(4,5)</code> 的结果。在这一点上，我们已经计算了顶级 <code>“+”</code> 运算符的操作数，剩下的所有操作都完成对 <code>operator.add(3,20)</code> 的调用。对于<code>（3+（4 * 5））</code>的整个表达式树的计算结果是 23。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.6.%E5%88%86%E6%9E%90%E6%A0%91/README/" data-id="clxzhp6k3002e1s8j8bih2xx2" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.5.节点表示/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.5.%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:13.003Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-5-节点表示"><a href="#6-5-节点表示" class="headerlink" title="6.5.节点表示"></a>6.5.节点表示</h2><p>我们的第二种表示树的方法使用节点和引用。在这种情况下，我们将定义一个具有根值属性的类，以及左和右子树。 由于这个表示更接近于面向对象的编程范例，我们将继续使用这个表示法用于本章的剩余部分。</p>
<p>使用节点和引用，我们认为树结构类似于 Figure 2 所示。</p>
<p><img src="/assets/6.5.%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA.figure2.png" alt="6.5.节点表示.figure2"></p>
<p><em>Figure 2</em></p>
<p>我们将从节点和引用方法的一个简单的类定义开始，如 Listing 4 所示。要记住这个表示重要的事情是 <code>left</code> 和 <code>right</code> 的属性将成为对 <code>BinaryTree</code> 类的其他实例的引用。 例如，当我们在树中插入一个新的左子节点时，我们创建另一个 <code>BinaryTree</code> 实例，并在根节点中修改<code>self.leftChild</code> 来引用新树节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rootObj</span>):</span><br><span class="line">        self.key = rootObj</span><br><span class="line">        self.leftChild = <span class="literal">None</span></span><br><span class="line">        self.rightChild = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p>请注意，在 Listing 4 中，构造函数希望获取某种对象存储在根中。 就像你可以在列表中存储任何你喜欢的对象一样，树的根对象可以是对任何对象的引用。 对于我们的先前示例，我们将存储节点的名称作为根值。使用节点和引用来表示 Figure 2 中的树，我们将创建 <code>BinaryTree</code> 类的六个实例。</p>
<p>接下来，我们来看看需要构建超出根节点的树的函数。要向树中添加一个左子树，我们将创建一个新的二叉树对象，并设置根的左边属性来引用这个新对象。 <code>insertLeft</code> 的代码如 Listing 5所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertLeft</span>(<span class="params">self,newNode</span>):</span><br><span class="line">    <span class="keyword">if</span> self.leftChild == <span class="literal">None</span>:</span><br><span class="line">        self.leftChild = BinaryTree(newNode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t = BinaryTree(newNode)</span><br><span class="line">        t.leftChild = self.leftChild</span><br><span class="line">        self.leftChild = t</span><br></pre></td></tr></table></figure>

<p><em>Listing 5</em></p>
<p>我们必须考虑两种插入情况。 第一种情况的特征没有现有左孩子的节点。当没有左孩子时，只需向树中添加一个节点。 第二种情况的特征在于具有现有左孩子的节点。在第二种情况下，我们插入一个节点并将现有的子节点放到树中的下一个层。第二种情况由 Listing 5 第 4 行的 else 语句处理。</p>
<p><code>insertRight</code> 的代码必须考虑一组对称的情况。没有右孩子，或者我们在根和现有右孩子之间插入节点。 插入代码如 Listing 6 所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertRight</span>(<span class="params">self,newNode</span>):</span><br><span class="line">    <span class="keyword">if</span> self.rightChild == <span class="literal">None</span>:</span><br><span class="line">        self.rightChild = BinaryTree(newNode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t = BinaryTree(newNode)</span><br><span class="line">        t.rightChild = self.rightChild</span><br><span class="line">        self.rightChild = t</span><br></pre></td></tr></table></figure>

<p><em>Listing 6</em></p>
<p>为了完成一个简单二叉树数据结构的定义，我们将实现获取 左和右孩子（见 Listing 7 ）以及根值的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">self,obj</span>):</span><br><span class="line">    self.key = obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.key</span><br></pre></td></tr></table></figure>

<p><em>Listing 7</em></p>
<p>现在我们有了创建和操作二叉树的所有部分，让我们使用它们来检查结构。 我们使用节点 a 作为根的简单树，并将节点 b 和 c 添加为子节点。 ActiveCode 1 创建树并查看存储在 key，left 和 right 中的一些值。注意，根的左和右孩子本身是 BinaryTree 类的不同实例。正如我们在对树的原始递归定义中所说的，这允许我们将二叉树的任何子项视为二叉树本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rootObj</span>):</span><br><span class="line">        self.key = rootObj</span><br><span class="line">        self.leftChild = <span class="literal">None</span></span><br><span class="line">        self.rightChild = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertLeft</span>(<span class="params">self,newNode</span>):</span><br><span class="line">        <span class="keyword">if</span> self.leftChild == <span class="literal">None</span>:</span><br><span class="line">            self.leftChild = BinaryTree(newNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.leftChild = self.leftChild</span><br><span class="line">            self.leftChild = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertRight</span>(<span class="params">self,newNode</span>):</span><br><span class="line">        <span class="keyword">if</span> self.rightChild == <span class="literal">None</span>:</span><br><span class="line">            self.rightChild = BinaryTree(newNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.rightChild = self.rightChild</span><br><span class="line">            self.rightChild = t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">self,obj</span>):</span><br><span class="line">        self.key = obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = BinaryTree(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.getRootVal())</span><br><span class="line"><span class="built_in">print</span>(r.getLeftChild())</span><br><span class="line">r.insertLeft(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.getLeftChild())</span><br><span class="line"><span class="built_in">print</span>(r.getLeftChild().getRootVal())</span><br><span class="line">r.insertRight(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.getRightChild())</span><br><span class="line"><span class="built_in">print</span>(r.getRightChild().getRootVal())</span><br><span class="line">r.getRightChild().setRootVal(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.getRightChild().getRootVal())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.5.%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA/README/" data-id="clxzhp6k3002g1s8jfzcj8uwo" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.4.列表表示/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.4.%E5%88%97%E8%A1%A8%E8%A1%A8%E7%A4%BA/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.994Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-4-列表表示"><a href="#6-4-列表表示" class="headerlink" title="6.4.列表表示"></a>6.4.列表表示</h2><p>在由列表表示的树中，我们将从 Python 的列表数据结构开始，并编写上面定义的函数。虽然将接口作为一组操作在列表上编写与我们实现的其他抽象数据类型有点不同，但这样做是有趣的，因为它为我们提供了一个简单的递归数据结构，我们可以直接查看和检查。在列表树的列表中，我们将根节点的值存储为列表的第一个元素。列表的第二个元素本身将是一个表示左子树的列表。列表的第三个元素将是表示右子树的另一个列表。为了说明这种存储技术，让我们看一个例子。 Figure 1 展示了一个简单的树和相应的列表实现。</p>
<p><img src="/assets/6.4.%E5%88%97%E8%A1%A8%E8%A1%A8%E7%A4%BA.figure1.png" alt="6.4.列表表示.figure1"></p>
<p><em>Figure 1</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myTree = [<span class="string">&#x27;a&#x27;</span>,   <span class="comment">#root</span></span><br><span class="line">      [<span class="string">&#x27;b&#x27;</span>,  <span class="comment">#left subtree</span></span><br><span class="line">       [<span class="string">&#x27;d&#x27;</span>, [], []],</span><br><span class="line">       [<span class="string">&#x27;e&#x27;</span>, [], []] ],</span><br><span class="line">      [<span class="string">&#x27;c&#x27;</span>,  <span class="comment">#right subtree</span></span><br><span class="line">       [<span class="string">&#x27;f&#x27;</span>, [], []],</span><br><span class="line">       [] ]</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>

<p>注意，我们可以使用标准列表索引来访问列表的子树。树的根是 <code>myTree[0]</code>，根的左子树是 <code>myTree[1]</code>，右子树是 <code>myTree[2]</code>。 ActiveCode 1 说明了使用列表创建一个简单的树。一旦树被构建，我们可以访问根和左右子树。 该列表方法的一个非常好的属性是表示子树的列表的结构遵守树定义的结构; 结构本身是递归的！具有根值和两个空列表的子树是叶节点。列表方法的另一个很好的特性是它可以推广到一个有许多子树的树。在树超过二叉树的情况下，另一个子树只是另一个列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myTree = [<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>,[],[]], [<span class="string">&#x27;e&#x27;</span>,[],[]] ], [<span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;f&#x27;</span>,[],[]], []] ]</span><br><span class="line"><span class="built_in">print</span>(myTree)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;left subtree = &#x27;</span>, myTree[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;root = &#x27;</span>, myTree[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;right subtree = &#x27;</span>, myTree[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><em>Activecode 1</em></p>
<p>让我们提供一些使我们能够使用列表作为树的函数来形式化树数据结构的这个定义。注意，我们不会定义一个二叉树类。我们写的函数只是帮助我们操纵一个标准列表，就像我们正在使用一棵树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BinaryTree</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="keyword">return</span> [r, [], []]</span><br></pre></td></tr></table></figure>

<p><code>BinaryTree</code> 函数简单地构造一个具有根节点和两个子列表为空的列表。要将左子树添加到树的根，我们需要在根列表的第二个位置插入一个新的列表。我们必须小心。如果列表已经在第二个位置有东西，我们需要跟踪它，并沿着树向下把它作为我们添加的列表的左子节点。Listing 1 展示了插入左子节点的 Python 代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertLeft</span>(<span class="params">root,newBranch</span>):</span><br><span class="line">    t = root.pop(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:</span><br><span class="line">        root.insert(<span class="number">1</span>,[newBranch,t,[]])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">1</span>,[newBranch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>注意，要插入一个左子节点，我们首先获得与当前左子节点对应的（可能为空的）列表。然后我们添加新的左子树，添加旧的左子数作为新子节点的左子节点。这允许我们在任何位置将新节点拼接到树中。<code>insertRight</code> 的代码与<code>insertLeft</code> 类似，如 Listing 2所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertRight</span>(<span class="params">root,newBranch</span>):</span><br><span class="line">    t = root.pop(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>,[newBranch,[],t])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>,[newBranch,[],[]])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>为了完成这组树形函数（见 Listing 3），让我们编写一些访问函数来获取和设置根节点的值，以及获取左或右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getRootVal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setRootVal</span>(<span class="params">root,newVal</span>):</span><br><span class="line">    root[<span class="number">0</span>] = newVal</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeftChild</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRightChild</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.4.%E5%88%97%E8%A1%A8%E8%A1%A8%E7%A4%BA/README/" data-id="clxzhp6k2002d1s8j6gl8h5xc" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.3.词汇和定义/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.3.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.983Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-3-词汇和定义"><a href="#6-3-词汇和定义" class="headerlink" title="6.3.词汇和定义"></a>6.3.词汇和定义</h2><p>我们已经看了树的示例，我们将正式定义树及其组件。</p>
<h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><p>节点是树的基本部分。它可以有一个名称，我们称之为“键”。节点也可以有附加信息。我们将这个附加信息称为“有效载荷”。虽然有效载荷信息不是许多树算法的核心，但在利用树的应用中通常是关键的。</p>
<h5 id="边"><a href="#边" class="headerlink" title="边"></a>边</h5><p>边是树的另一个基本部分。边连接两个节点以显示它们之间存在关系。每个节点（除根之外）都恰好从另一个节点的传入连接。每个节点可以具有多个输出边。</p>
<h5 id="根"><a href="#根" class="headerlink" title="根"></a>根</h5><p>树的根是树中唯一没有传入边的节点。在 Figure 2 中，&#x2F; 是树的根。</p>
<h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><p>路径是由边连接节点的有序列表。例如， $$Mammal \to Carnivora \to Felidae \to Felis \to Domestica$$ 是一条路径。</p>
<h5 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h5><p>具有来自相同传入边的节点 c 的集合称为该节点的子节点。在 Figure 2中，节点 log&#x2F;，spool&#x2F; 和 yp&#x2F; 是节点 var&#x2F; 的子节点。</p>
<h5 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h5><p>具有和它相同传入边的所连接的节点称为父节点。在 Figure 2 中，节点 var&#x2F; 是节点 log&#x2F;，spool&#x2F; 和 yp&#x2F; 的父节点。</p>
<h5 id="兄弟"><a href="#兄弟" class="headerlink" title="兄弟"></a>兄弟</h5><p>树中作为同一父节点的子节点的节点被称为兄弟节点。节点 etc&#x2F; 和 usr&#x2F; 是文件系统树中的兄弟节点。</p>
<h5 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h5><p>子树是由父节点和该父节点的所有后代组成的一组节点和边。</p>
<h5 id="叶节点"><a href="#叶节点" class="headerlink" title="叶节点"></a>叶节点</h5><p>叶节点是没有子节点的节点。 例如，人类和黑猩猩是 Figure 1 中的叶节点。</p>
<h5 id="层数"><a href="#层数" class="headerlink" title="层数"></a>层数</h5><p>节点 n 的层数为从根结点到该结点所经过的分支数目。 例如，图1中的Felis节点的级别为五。根据定义，根节点的层数为零。</p>
<h5 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h5><p>树的高度等于树中任何节点的最大层数。 Figure 2 中的树的高度是 2。</p>
<p>现在已经定义了基本词汇，我们可以继续对树的正式定义。 事实上，我们将提供一个树的两个定义。 一个定义涉及节点和边。 第二个定义，将被证明是非常有用的，是一个递归定义。</p>
<p>定义一：树由一组节点和一组连接节点的边组成。树具有以下属性：</p>
<ul>
<li>树的一个节点被指定为根节点。</li>
<li>除了根节点之外，每个节点 n 通过一个其他节点 p 的边连接，其中 p 是 n 的父节点。</li>
<li>从根路径遍历到每个节点路径唯一。</li>
<li>如果树中的每个节点最多有两个子节点，我们说该树是一个二叉树。</li>
</ul>
<p>Figure 3 展示了适合定义一的树。边上的箭头指示连接的方向。</p>
<p><img src="/assets/6.3.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89.figure3.png" alt="6.3.词汇和定义.figure3"></p>
<p><em>Figure 3</em></p>
<p>定义二：树是空的，或者由一个根节点和零个或多个子树组成，每个子树也是一棵树。每个子树的根节点通过边连接到父树的根节点。 Figure 4 说明了树的这种递归定义。使用树的递归定义，我们知道 Figure 4 中的树至少有四个节点，因为表示一个子树的每个三角形必须有一个根节点。 它可能有比这更多的节点，但我们不知道，除非我们更深入树。</p>
<p><img src="/assets/6.3.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89.figure4.png" alt="6.3.词汇和定义.figure4"></p>
<p><em>Figure 4</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.3.%E8%AF%8D%E6%B1%87%E5%92%8C%E5%AE%9A%E4%B9%89/README/" data-id="clxzhp6k2002c1s8jer4o00rb" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.9.%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.8.%E6%9E%84%E5%BB%BA%E5%AD%97%E6%A2%AF%E5%9B%BE/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.7.%E5%AD%97%E6%A2%AF%E7%9A%84%E9%97%AE%E9%A2%98/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.6.%E5%AE%9E%E7%8E%B0/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.5.%E9%82%BB%E6%8E%A5%E8%A1%A8/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FLITl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>