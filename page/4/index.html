<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FLITl的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些感想，一些技术，一些生活。">
<meta property="og:type" content="website">
<meta property="og:title" content="FLITl的博客">
<meta property="og:url" content="http://jackfrued.top/page/4/index.html">
<meta property="og:site_name" content="FLITl的博客">
<meta property="og:description" content="一些感想，一些技术，一些生活。">
<meta property="og:locale">
<meta property="article:author" content="FLITl">
<meta property="article:tag" content="反思，技术，生活">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="FLITl的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FLITl的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天命之谓性；率性之谓道；修道之谓教。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jackfrued.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.2.树的例子/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.2.%E6%A0%91%E7%9A%84%E4%BE%8B%E5%AD%90/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.972Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-2-树的例子"><a href="#6-2-树的例子" class="headerlink" title="6.2.树的例子"></a>6.2.树的例子</h2><p>现在我们已经研究了线性数据结构，如栈和队列，并且有一些递归的经验，我们将看一个称为树的常见数据结构。树在计算机科学的许多领域中使用，包括操作系统，图形，数据库系统和计算机网络。树数据结构与他们的植物表亲有许多共同之处。树数据结构具有根，分支和叶。自然界中的树和计算机科学中的树之间的区别在于树数据结构的根在顶部，其叶在底部。</p>
<p>在我们开始研究树形数据结构之前，让我们来看几个常见的例子。我们树的第一个例子是生物学的分类树。Figure 1 展示了一些动物的生物分类的实例。从这个简单的例子，我们可以了解树的几个属性。此示例演示的第一个属性是树是分层的。通过分层，我们的意思是树的层次结构，更接近顶部的是抽象的东西和底部附近是更具体的东西。层次结构的顶部是 <code>Kingdom</code>，树的下一层（上面的层的“Children”）是 <code>Phylum</code>，然后是 <code>Class</code>，等等。然而，无论我们在分类树中有多深，所有的生物仍然是 <code>animals</code>。</p>
<p><img src="/assets/6.2.%E6%A0%91%E7%9A%84%E4%BE%8B%E5%AD%90.figure1.png" alt="6.2.树的例子.figure1"></p>
<p><em>Figure 1</em></p>
<p>注意，你可以从树的顶部开始，并沿着圆圈和箭头一直到底部的路径。在树的每一层，我们可能问自己一个问题，然后遵循与我们的答案一致的路径。例如，我们可能会问，“这个动物是Chordate(脊椎动物)还是Arthropod(节肢动物)？”如果答案是“Chordate”，那么我们遵循这条路径，问“这个Chordate是 Mammal(哺乳动物)吗？”如果不是，我们就卡住了这个简化的例子）。当我们在哺乳动物那层时，我们问“这个哺乳动物是Primate(灵长类动物)还是 Carnivore(食肉动物)？”我们可以遵循以下路径，直到我们到达树的最底部，在那里我们有共同的名字。</p>
<p>树的第二个属性是一个节点的所有子节点独立于另一个节点的子节点。例如，Felis 有属于 Domestica 和 Leo 的孩子。Musca 也有一个名为 Domestica 的孩子，但它是一个不同的节点，并独立于 Felis 的 Domestica孩子。这意味着我们可以改变作为 Musca 的孩子的节点而不影响 Felis 的孩子。</p>
<p>第三个属性是每个叶节点是唯一的。我们可以指定从树的根到唯一地识别动物王国中的每个物种的叶的路径;例如，Animalia→→Chordate→→Mammal→→Carnivora→→Felidae→→Felis→→Domestica。</p>
<p>你可能每天使用的树结构的另一个示例是文件系统。在文件系统中，目录或文件夹被构造为树。Figure 2 说明了 Unix文件系统层次结构的一小部分。</p>
<p><img src="/assets/6.2.%E6%A0%91%E7%9A%84%E4%BE%8B%E5%AD%90.figure2.png" alt="6.2.树的例子.figure2"></p>
<p><em>Figure2</em></p>
<p>文件系统树与生物分类树有很多共同之处。你可以遵循从根目录到任何目录的路径。 该路径将唯一标识该子目录（及其中的所有文件）。 树的另一个重要属性来源于它们的层次性质，你可以将树的整个部分（称为子树）移动到树中的不同位置，而不影响层次结构的较低级别。 例如，我们可以使用整个子树 &#x2F;etc&#x2F;，从根节点分离，并重新附加在 usr&#x2F; 下。 这将把 httpd 的唯一路径名从 &#x2F;etc&#x2F;httpd 更改为 &#x2F;usr&#x2F;etc&#x2F;httpd，但不会影响 httpd 目录的内容或任何子级。</p>
<p>树的最后一个例子是网页。 以下是使用HTML编写的简单网页的示例。 Figure 3 展示了用于创建页面的每个 HTML 标记的树。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xml:lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>simple<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>A simple web page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.cs.luther.edu&quot;</span>&gt;</span>Luther CS <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/6.2.%E6%A0%91%E7%9A%84%E4%BE%8B%E5%AD%90.figure3.png" alt="6.2.树的例子.figure3"></p>
<p><em>Figure 3</em></p>
<p>HTML源代码和伴随源的树说明了另一个层次结构。请注意，树的每个级别都对应于HTML标记内的嵌套级别。源中的第一个标记是 <code>&lt;html&gt;</code>，最后一个是<code>&lt;/html&gt;</code> 页面中的所有其余标记都是成对的。 如果你检查，你会看到这个嵌套属性在树的所有级别都是 true。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.2.%E6%A0%91%E7%9A%84%E4%BE%8B%E5%AD%90/README/" data-id="clxzhp6k3002h1s8je5yc9zdx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.19.总结/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.19.%E6%80%BB%E7%BB%93/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.968Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-19-总结"><a href="#6-19-总结" class="headerlink" title="6.19.总结"></a>6.19.总结</h2><p>在这一章中，我们看了树的数据结构。 树数据结构使我们能够编写许多有趣的算法。 在本章中，我们研究了使用树来执行以下操作的算法：</p>
<ul>
<li>用于解析和计算表达式的二叉树。</li>
<li>用于实现 Map ADT的二叉树。</li>
<li>用于实现 Map ADT的平衡二叉树（AVL树）。</li>
<li>一个二叉树实现一个最小堆。</li>
<li>用于实现优先级队列的最小堆。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.19.%E6%80%BB%E7%BB%93/README/" data-id="clxzhp6k2002b1s8j5k3sh43d" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.18.Map抽象数据结构总结/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.18.Map%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.960Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-18-Map抽象数据结构总结"><a href="#6-18-Map抽象数据结构总结" class="headerlink" title="6.18.Map抽象数据结构总结"></a>6.18.Map抽象数据结构总结</h2><p>在前面两章中，我们已经研究了可以用于实现 Map 抽象数据类型的几个数据结构。二叉搜索表，散列表，二叉搜索树和平衡二叉搜索树。 总结这一节，让我们总结 Map ADT 定义的关键操作的每个数据结构的性能（见Table 1）。</p>
<p><img src="/assets/6.18.Map%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93.table1.png" alt="6.18.Map抽象数据结构总结.table1"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.18.Map%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/README/" data-id="clxzhp6k3002f1s8j1ulxabs6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.17.AVL平衡二叉搜索树实现/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.17.AVL%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.945Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-17-AVL平衡二叉搜索树实现"><a href="#6-17-AVL平衡二叉搜索树实现" class="headerlink" title="6.17.AVL平衡二叉搜索树实现"></a>6.17.AVL平衡二叉搜索树实现</h2><p>现在我们已经证明保持 AVL树的平衡将是一个很大的性能改进，让我们看看如何增加过程来插入一个新的键到树。由于所有新的键作为叶节点插入到树中，并且我们知道新叶的平衡因子为零，所以刚刚插入的节点没有新的要求。但一旦添加新叶，我们必须更新其父的平衡因子。这个新叶如何影响父的平衡因子取决于叶节点是左孩子还是右孩子。如果新节点是右子节点，则父节点的平衡因子将减少1。如果新节点是左子节点，则父节点的平衡因子将增加1。这个关系可以递归地应用到新节点的祖父节点，并且应用到每个祖先一直到树的根。由于这是一个递归过程，我们来看一下用于更新平衡因子的两种基本情况：</p>
<ul>
<li>递归调用已到达树的根。</li>
<li>父节点的平衡因子已调整为零。你应该说服自己，一旦一个子树的平衡因子为零，那么它的祖先节点的平衡不会改变。</li>
</ul>
<p>我们将实现 AVL 树作为 <code>BinarySearchTree</code> 的子类。首先，我们将覆盖<code>_put</code> 方法并编写一个新的 <code>updateBalance</code> 辅助方法。这些方法如Listing 1所示。你将注意到，<code>_put</code> 的定义与简单二叉搜索树中的完全相同，除了第 7 行和第 13 行上对 <code>updateBalance</code> 的调用的添加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">self,key,val,currentNode</span>):</span><br><span class="line">    <span class="keyword">if</span> key &lt; currentNode.key:</span><br><span class="line">        <span class="keyword">if</span> currentNode.hasLeftChild():</span><br><span class="line">                self._put(key,val,currentNode.leftChild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                currentNode.leftChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line">                self.updateBalance(currentNode.leftChild)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> currentNode.hasRightChild():</span><br><span class="line">                self._put(key,val,currentNode.rightChild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                currentNode.rightChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line">                self.updateBalance(currentNode.rightChild)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">updateBalance</span>(<span class="params">self,node</span>):</span><br><span class="line">    <span class="keyword">if</span> node.balanceFactor &gt; <span class="number">1</span> <span class="keyword">or</span> node.balanceFactor &lt; -<span class="number">1</span>:</span><br><span class="line">        self.rebalance(node)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> node.parent != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> node.isLeftChild():</span><br><span class="line">                node.parent.balanceFactor += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> node.isRightChild():</span><br><span class="line">                node.parent.balanceFactor -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.parent.balanceFactor != <span class="number">0</span>:</span><br><span class="line">                self.updateBalance(node.parent)</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>新的 <code>updateBalance</code> 方法完成了大多数工作。这实现了我们刚才描述的递归过程。 <code>updateBalance</code> 方法首先检查当前节点是否不够平衡，需要重新平衡（第16行）。如果平衡，则重新平衡完成，并且不需要对父节点进行进一步更新。如果当前节点不需要重新平衡，则调整父节点的平衡因子。如果父的平衡因子不为零，那么算法通过递归调用父对象上的 <code>updateBalance</code>，继续沿树向根向上运行。</p>
<p>当需要树重新平衡时，我们如何做呢？有效的重新平衡是使AVL树在不牺牲性能的情况下正常工作的关键。为了使AVL树恢复平衡，我们将在树上执行一个或多个旋转。</p>
<p>要理解旋转是什么让我们看一个非常简单的例子。考虑 Figure 3左半部分的树。这棵树平衡因子为 -2，不平衡。为了使这棵树平衡，我们将使用以节点 A 为根的子树的左旋转。</p>
<p><img src="/assets/6.16.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0.figure3.png" alt="6.16.平衡二叉搜索树实现.figure3"></p>
<p><em>Figure 3</em></p>
<p>要执行左旋转，我们基本上执行以下操作：</p>
<ul>
<li>提升右孩子（B）成为子树的根。</li>
<li>将旧根（A）移动为新根的左子节点。</li>
<li>如果新根（B）已经有一个左孩子，那么使它成为新左孩子（A）的右孩子。注意：由于新根（B）是A的右孩子，A 的右孩子在这一点上保证为空。这允许我们添加一个新的节点作为右孩子，不需进一步的考虑。</li>
</ul>
<p>虽然这个过程在概念上相当容易，但是代码的细节有点棘手，因为我们需要按照正确的顺序移动事物，以便保留二叉搜索树的所有属性。此外，我们需要确保适当地更新所有的父指针。</p>
<p>让我们看一个稍微更复杂的树来说明右旋转。Figure 4的左侧显示了树的左重，在根处的平衡因子为 2。要执行右旋转，我们基本上执行以下操作：</p>
<ul>
<li>提升左子节点（C）为子树的根。</li>
<li>将旧根（E）移动为新根的右子树。</li>
<li>如果新根（C）已经有一个正确的孩子（D），那么使它成为新的右孩子（E）的左孩子。注意：由于新根（C）是 E 的左子节点，因此 E 的左子节点在此时保证为空。这允许我们添加一个新节点作为左孩子，不需进一步的考虑。</li>
</ul>
<p><img src="/assets/6.16.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0.figure4.png" alt="6.16.平衡二叉搜索树实现.figure4"></p>
<p><em>Figure 4</em></p>
<p>现在你已经看到了旋转，并且有旋转的工作原理的基本概念，让我们看看代码。Listing 2展示了右旋转和左旋转的代码。在第2行中，我们创建一个临时变量来跟踪子树的新根。正如我们之前所说的，新的根是上一个根的右孩子。现在对这个临时变量存储了一个对右孩子的引用，我们用新的左孩子替换旧根的右孩子。</p>
<p>下一步是调整两个节点的父指针。如果 newRoot 有一个左子节点，那么左子节点的新父节点变成旧的根节点。新根的父节点设置为旧根的父节点。如果旧根是整个树的根，那么我们必须设置树的根以指向这个新根。否则，如果旧根是左孩子，则我们将左孩子的父节点更改为指向新根;否则我们改变右孩子的父亲指向新的根。（行10-13）。最后，我们将旧根的父节点设置为新根。这是一个很复杂的过程，所以我们鼓励你跟踪这个功能，同时看下 Figure 3。 <code>rotateRight</code> 方法是对称的 <code>rotateLeft</code>，所以我们将留给你来研究 <code>rotateRight</code> 的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rotateLeft</span>(<span class="params">self,rotRoot</span>):</span><br><span class="line">    newRoot = rotRoot.rightChild</span><br><span class="line">    rotRoot.rightChild = newRoot.leftChild</span><br><span class="line">    <span class="keyword">if</span> newRoot.leftChild != <span class="literal">None</span>:</span><br><span class="line">        newRoot.leftChild.parent = rotRoot</span><br><span class="line">    newRoot.parent = rotRoot.parent</span><br><span class="line">    <span class="keyword">if</span> rotRoot.isRoot():</span><br><span class="line">        self.root = newRoot</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> rotRoot.isLeftChild():</span><br><span class="line">                rotRoot.parent.leftChild = newRoot</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rotRoot.parent.rightChild = newRoot</span><br><span class="line">    newRoot.leftChild = rotRoot</span><br><span class="line">    rotRoot.parent = newRoot</span><br><span class="line">    rotRoot.balanceFactor = rotRoot.balanceFactor + <span class="number">1</span> - <span class="built_in">min</span>(newRoot.balanceFactor, <span class="number">0</span>)</span><br><span class="line">    newRoot.balanceFactor = newRoot.balanceFactor + <span class="number">1</span> + <span class="built_in">max</span>(rotRoot.balanceFactor, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>最后，第16-17行需要一些解释。 在这两行中，我们更新旧根和新根的平衡因子。 由于所有其他移动都是移动整个子树，所以所有其他节点的平衡因子不受旋转的影响。 但是我们如何在不完全重新计算新子树的高度的情况下更新平衡因子呢？ 以下推导应该能说服你这些行是正确的。</p>
<p><img src="/assets/6.16.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0.figure5.png" alt="6.16.平衡二叉搜索树实现.figure5"></p>
<p><em>Figure 5</em></p>
<p>Figure 5 展示了左旋转。 B 和 D 是关键节点，A，C，E 是它们的子树。 设hx 表示以节点 x 为根的特定子树的高度。 根据定义，我们知道以下：</p>
<p>$$<br>\begin{aligned}<br>newBal(B)&amp;&#x3D;hA-hC\<br>oldBal(B)&amp;&#x3D;hA-hD<br>\end{aligned}<br>$$</p>
<p>但我们知道，D 的旧高度也可以由 <code>1 + max(hC，hE)</code>给出，也就是说，D 的高度比其两个孩子的最大高度大 1。 记住，<code>hC</code>和 <code>hE</code> 没有改变。 所以，让我们用第二个方程来代替它</p>
<p>$$<br>oldBal(B)&#x3D;hA-(1+max(hC,hE))<br>$$</p>
<p>然后减去这两个方程。 以下步骤进行减法并使用一些代数来简化 <code>newBal(B)</code> 的等式。</p>
<p>$$<br>\begin{aligned}<br>newBal(B)-oldBal(B)&amp;&#x3D;hA-hC-(hA-(1+max(hC,hE)))\<br>newBal(B)-oldBal(B)&amp;&#x3D;hA-hC-hA+(1+max(hC,hE))\<br>newBal(B)-oldBal(B)&amp;&#x3D;hA-hA+1+max(hC,hE)-hC\<br>newBal(B)-oldBal(B)&amp;&#x3D;1+max(hC,hE)-hC<br>\end{aligned}<br>$$</p>
<p>接下来我们将 oldBal(B) 移动到方程的右边，并利用 <code>max(a，b) -c = max(a-c，b-c)</code>。</p>
<p>$$<br>newBal(B)&#x3D;oldBal(B)+1+max(hC-hC,hE-hC)<br>$$</p>
<p>但是，$$hE-hC$$ 与 $$-oldBal(D)$$ 相同。因此，我们可以使用另一个表示 $$max(-a, -b) &#x3D; -min(a, b)$$ 的标识。 因此，我们可以完成我们的 newBal(B) 的推导，具有以下步骤：</p>
<p>$$<br>\begin{aligned}<br>newBal(B)&amp;&#x3D;oldBal(B)+1+max(0,-oldBal(D))\<br>newBal(B)&amp;&#x3D;oldBal(B)+1-min(0,oldBal(D))<br>\end{aligned}<br>$$</p>
<p>现在我们有所有的部分，我们很容易知道。 我们记住 B 是 rotRoot 和 D 是newRoot 然后我们可以看到这正好对应第16行的语句，或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotRoot.balanceFactor = rotRoot.balanceFactor + <span class="number">1</span> - <span class="built_in">min</span>(<span class="number">0</span>,newRoot.balanceFactor)</span><br></pre></td></tr></table></figure>

<p>类似的推导给出了更新的节点 D 的方程，以及右旋转后的平衡因子。 我们把这些作为你的练习。</p>
<p>现在你可能认为我们已经完成了。 我们知道如何做左右旋转，我们知道什么时候应该做左旋或右旋，但是看看 Figure 6。由于节点 A 的平衡因子为-2，我们应该做左旋转。 但是，当我们围绕A做左旋转时会发生什么？</p>
<p><img src="/assets/6.16.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0.figure6.png" alt="6.16.平衡二叉搜索树实现.figure6"></p>
<p><em>Figure 6</em></p>
<p>Figure 7 展示了我们在左旋后，我们现在已经在另一方面失去平衡。 如果我们做右旋以纠正这种情况，我们就回到我们开始的地方。<br><img src="/assets/6.16.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0.figure7.png" alt="6.16.平衡二叉搜索树实现.figure7"></p>
<p><em>Figure 7</em></p>
<p>要纠正这个问题，我们必须使用以下规则集：</p>
<ul>
<li>如果子树需要左旋转使其平衡，首先检查右子节点的平衡因子。 如果右孩子是重的，那么对右孩子做右旋转，然后是原来的左旋转。</li>
<li>如果子树需要右旋转使其平衡，首先检查左子节点的平衡因子。 如果左孩子是重的，那么对左孩子做左旋转，然后是原来的右旋转。</li>
</ul>
<p>Figure 8展示了这些规则如何解决我们在Figure 6和 Figure 7中遇到的困境。从围绕节点 C的 右旋转开始，将树放置在 A 的左旋转使整个子树恢复平衡的位置。</p>
<p><img src="/assets/6.16.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0.figure8.png" alt="6.16.平衡二叉搜索树实现.figure8"></p>
<p><em>Figure 8</em></p>
<p>实现这些规则的代码可以在我们的重新平衡方法中找到，如 Listing 3所示。上面的规则编号 1 是从第2行开始的if语句实现的。规则编号2是由第8行开始的elif语句实现的 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rebalance</span>(<span class="params">self,node</span>):</span><br><span class="line">  <span class="keyword">if</span> node.balanceFactor &lt; <span class="number">0</span>:</span><br><span class="line">         <span class="keyword">if</span> node.rightChild.balanceFactor &gt; <span class="number">0</span>:</span><br><span class="line">            self.rotateRight(node.rightChild)</span><br><span class="line">            self.rotateLeft(node)</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            self.rotateLeft(node)</span><br><span class="line">  <span class="keyword">elif</span> node.balanceFactor &gt; <span class="number">0</span>:</span><br><span class="line">         <span class="keyword">if</span> node.leftChild.balanceFactor &lt; <span class="number">0</span>:</span><br><span class="line">            self.rotateLeft(node.leftChild)</span><br><span class="line">            self.rotateRight(node)</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            self.rotateRight(node)</span><br></pre></td></tr></table></figure>
<p><em>Listing 3</em></p>
<p>通过保持树在所有时间的平衡，我们可以确保 get 方法将按 $$O(log2(n))$$ 时间运行。但问题是我们的 put 方法有什么成本？让我们将它分解为 put 执行的操作。由于将新节点作为叶子插入，更新所有父节点的平衡因子将需要最多 $$log2^n$$ 运算，树的每层一个运算。如果发现子树不平衡，则需要最多两次旋转才能使树重新平衡。但是，每个旋转在 $$O(1)$$ 时间中工作，因此我们的put操作仍然是 $$O(log2^n)$$。</p>
<p>在这一点上，我们已经实现了一个功能AVL树，除非你需要删除一个节点的能力。我们保留删除节点和随后的更新和重新平衡作为一个练习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.17.AVL%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/README/" data-id="clxzhp6k2002a1s8jbig162qp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.16.AVL平衡二叉搜索树/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.16.AVL%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.937Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-16-AVL平衡二叉搜索树"><a href="#6-16-AVL平衡二叉搜索树" class="headerlink" title="6.16.AVL平衡二叉搜索树"></a>6.16.AVL平衡二叉搜索树</h2><p>在我们继续之前，我们来看看执行这个新的平衡因子要求的结果。我们的主张是，通过确保树总是具有 -1,0或1 的平衡因子，我们可以获得更好的操作性能的关键操作。 让我们开始思考这种平衡条件如何改变最坏情况的树。有两种可能性，一个左重树和一个右重树。 如果我们考虑高度0,1,2和3的树，Figure 2 展示了在新规则下可能的最不平衡的左重树。</p>
<p><img src="/assets/6.16.AVL%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.figure1.png" alt="6.16.AVL平衡二叉搜索树.figure1"></p>
<p><em>Figure 2</em></p>
<p>看树中节点的总数，我们看到对于高度为0的树，有1个节点，对于高度为1的树，有1 + 1 &#x3D; 2个节点，对于高度为2的树 是1 + 1 + 2 &#x3D; 4，对于高度为3的树，有1 + 2 + 4 &#x3D; 7。 更一般地，我们看到的高度h(Nh) 的树中的节点数量的模式是：</p>
<p>$$<br>N_h &#x3D; 1 + N_{h-1} + N_{h-2}<br>$$</p>
<p>这种可能看起来很熟悉，因为它非常类似于斐波纳契序列。 给定树中节点的数量，我们可以使用这个事实来导出AVL树的高度的公式。 回想一下，对于斐波纳契数列，第i个斐波纳契数字由下式给出：</p>
<p>$$<br>\begin{aligned}<br>F_0 &#x3D; 0 \<br>F_1 &#x3D; 1 \<br>F_i &#x3D; F_{i-1} + F_{i-2}  \text{ for all } i \ge 2<br>\end{aligned}<br>$$</p>
<p>一个重要的数学结果是，随着斐波纳契数列越来越大，$$F_i&#x2F;F_{i-1}$$ 的比率越来越接近黄金比率 $$\Phi &#x3D; \frac{(1 +\sqrt{5})}{2}$$。 如果要查看上一个方程的导数，可以查阅数学文本。 我们将简单地使用该方程来近似 Fi，如 $$Fi &#x3D;\Phi^i &#x2F; 5$$。 如果我们利用这个近似，我们可以重写 Nh 的方程为：</p>
<p>$$<br>N_h &#x3D; F_{h+2} - 1, h \ge 1<br>$$</p>
<p>通过用其黄金比例近似替换斐波那契参考，我们得到：</p>
<p>$$<br>N_h &#x3D; \frac{\Phi^{h+2}}{\sqrt{5}} - 1<br>$$</p>
<p>如果我们重新排列这些项，并取两边的底数为2的对数，然后求解 h，我们得到以下推导：</p>
<p>$$<br>\begin{aligned}<br>\log{N_h+1} &#x3D; (H+2)\log{\Phi} - \frac{1}{2} \log{5} \<br>h &#x3D; \frac{\log{N_h+1} - 2 \log{\Phi} + \frac{1}{2} \log{5}}{\log{\Phi}} \<br>h &#x3D; 1.44 \log{N_h}<br>\end{aligned}<br>$$</p>
<p>这个推导告诉我们，在任何时候，我们的AVL树的高度等于树中节点数目的对数的常数（1.44）倍。 这是搜索我们的AVL树的好消息，因为它将搜索限制为 $$O(logN)$$。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.16.AVL%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/README/" data-id="clxzhp6k100271s8j0sru4zgy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.15.平衡二叉搜索树/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.15.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.930Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-15-平衡二叉搜索树"><a href="#6-15-平衡二叉搜索树" class="headerlink" title="6.15.平衡二叉搜索树"></a>6.15.平衡二叉搜索树</h2><p>在上一节中，我们考虑构建一个二叉搜索树。正如我们所学到的，二叉搜索树的性能可以降级到 $$O(n)$$ 的操作，如 <code>get</code> 和 <code>put</code> ，如果树变得不平衡。在本节中，我们将讨论一种特殊类型的二叉搜索树，它自动确保树始终保持平衡。这棵树被称为 AVL树，以其发明人命名：G.M. Adelson-Velskii 和E.M.Landis。</p>
<p>AVL树实现 Map 抽象数据类型就像一个常规的二叉搜索树，唯一的区别是树的执行方式。为了实现我们的 AVL树，我们需要跟踪树中每个节点的平衡因子。我们通过查看每个节点的左右子树的高度来做到这一点。更正式地，我们将节点的平衡因子定义为左子树的高度和右子树的高度之间的差。</p>
<p>$$<br>balanceFactor &#x3D; height(leftSubTree) - height(rightSubTree)<br>$$</p>
<p>使用上面给出的平衡因子的定义，我们说如果平衡因子大于零，则子树是左重的。如果平衡因子小于零，则子树是右重的。如果平衡因子是零，那么树是完美的平衡。为了实现AVL树，并且获得具有平衡树的好处，如果平衡因子是 -1,0 或 1，我们将定义树平衡。一旦树中的节点的平衡因子是在这个范围之外，我们将需要一个程序来使树恢复平衡。Figure 1展示了不平衡，右重树和每个节点的平衡因子的示例。</p>
<p><img src="/assets/6.15.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.figure1.png" alt="6.15.平衡二叉搜索树.figure1"></p>
<p><em>Figure 1</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.15.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/README/" data-id="clxzhp6k200281s8jab56d3hg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.14.查找树分析/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.14.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%88%86%E6%9E%90/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.923Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-14-查找树分析"><a href="#6-14-查找树分析" class="headerlink" title="6.14.查找树分析"></a>6.14.查找树分析</h2><p>随着二叉搜索树的实现完成，我们将对已经实现的方法进行快速分析。让我们先来看看 <code>put</code> 方法。其性能的限制因素是二叉树的高度。从词汇部分回忆一下树的高度是根和最深叶节点之间的边的数量。高度是限制因素，因为当我们寻找合适的位置将一个节点插入到树中时，我们需要在树的每个级别最多进行一次比较。</p>
<p>二叉树的高度可能是多少？这个问题的答案取决于如何将键添加到树。如果按照随机顺序添加键，树的高度将在 $$log2^n$$ 附近，其中 n 是树中的节点数。这是因为如果键是随机分布的，其中大约一半将小于根，一半大于根。请记住，在二叉树中，根节点有一个节点，下一级节点有两个节点，下一个节点有四个节点。任何特定级别的节点数为 $$2^d$$ ，其中 d 是级别的深度。完全平衡的二叉树中的节点总数为 $$2^{h+1} - 1$$，其中 h 表示树的高度。</p>
<p>完全平衡的树在左子树中具有与右子树相同数量的节点。在平衡二叉树中，<code>put</code> 的最坏情况性能是 $$O(log2^n)$$，其中 n 是树中的节点数。注意，这是与前一段中的计算的反比关系。所以 log2^⁡n 给出了树的高度，并且表示了在适当的位置插入新节点时，需要做的最大比较次数。</p>
<p>不幸的是，可以通过以排序顺序插入键来构造具有高度 n 的搜索树！这样的树的示例见 Figure 6。在这种情况下，put方法的性能是 $$O(n)$$。</p>
<p><img src="/assets/6.14.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%88%86%E6%9E%90.figure6.png" alt="6.14.查找树分析.figure6"></p>
<p><em>Figure 6</em></p>
<p>现在你明白了 <code>put</code> 方法的性能受到树的高度的限制，你可能猜测其他方法 <code>get</code>，<code>in</code> 和 <code>del</code> 也是有限制的。 由于 <code>get</code> 搜索树以找到键，在最坏的情况下，树被一直搜索到底部，并且没有找到键。 乍一看，<code>del</code> 似乎更复杂，因为它可能需要在删除操作完成之前搜索后继。 但请记住，找到后继者的最坏情况也只是树的高度，这意味着你只需要加倍工作。 因为加倍是一个常数因子，它不会改变最坏的情况</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.14.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%88%86%E6%9E%90/README/" data-id="clxzhp6k100261s8jaacvgknj" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.13.查找树实现/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.907Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-13-查找树实现"><a href="#6-13-查找树实现" class="headerlink" title="6.13.查找树实现"></a>6.13.查找树实现</h2><p>二叉搜索树依赖于在左子树中找到的键小于父节点的属性，并且在右子树中找到的键大于父代。 我们将这个称为 bst属性。 当我们如上所述实现 Map 接口时，bst 属性将指导我们的实现。 Figure 1说明了二叉搜索树的此属性，展示了没有任何关联值的键。请注意，该属性适用于每个父级和子级。 左子树中的所有键小于根中的键。 右子树中的所有键都大于根。</p>
<p><img src="/assets/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0.figure1.png" alt="6.13.查找树实现.figure1"></p>
<p><em>Figure1</em></p>
<p>现在你知道什么是二叉搜索树，我们将看看如何构造二叉搜索树。Figure 1中的搜索树表示在按照所示的顺序插入以下键之后存在的节点：<code>70,31,93,94,14,23,73</code>。因为 70 是插入树中的第一个键，它是根。接下来，31 小于 70，所以它成为 70 的左孩子。接下来，93 大于 70，所以它成为 70 的右孩子。现在我们有两层的树填充，所以下一个键 94 ，因为 94 大于70 和 93，它成为 93 的右孩子。类似地，14 小于 70 和 31，所以它变成 31 的左孩子。23 也小于 31，所以它必须在左子树 31 中。但是，它大于14，所以它成为 14 的右孩子。</p>
<p>为了实现二叉搜索树，我们将使用类似于我们用于实现链表的节点和引用方法，以及表达式树。但是，因为我们必须能够创建和使用一个空的二叉搜索树，我们的实现将使用两个类。第一个类称为 <code>BinarySearchTree</code>，第二个类称为<code>TreeNode</code>。 <code>BinarySearchTree</code> 类具有对作为二叉搜索树的根的<code>TreeNode</code> 的引用。在大多数情况下，外部类中定义的外部方法只是检查树是否为空。如果树中有节点，请求只是传递到 <code>BinarySearchTree</code> 类中定义的私有方法，该方法以 root 作为参数。在树是空的或者我们想要删除树根的键的情况下，我们必须采取特殊的行动。 <code>BinarySearchTree</code> 类构造函数的代码以及一些其他杂项函数如Listing 1所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.root.__iter__()</span><br></pre></td></tr></table></figure>

<p><em>Listing 1</em></p>
<p>TreeNode 类提供了许多辅助函数，使得在 <code>BinarySearchTree</code> 类方法中完成的工作更容易。 <code>TreeNode</code> 的构造函数以及这些辅助函数如 Listing 2所示。你可以在列表中看到许多辅助函数根据自己的位置将节点分类为子节点（左或右）和节点具有的子节点类型。 <code>TreeNode</code> 类还将显式地跟踪父节点作为每个节点的属性。当我们讨论 del 操作符的实现时，你会看到为什么这很重要。</p>
<p>Listing 2 中 <code>TreeNode</code> 另一个有趣的方面是我们使用 Python 的可选参数。可选参数使我们能够在几种不同的情况下轻松创建 <code>TreeNode</code> 。有时我们想要构造一个已经同时具有父和子的新 <code>TreeNode</code> 。对于现有的父和子，我们可以传递父和子作为参数。在其他时候，我们将使用键值对创建一个<code>TreeNode</code>，我们不会为父或子传递任何参数。在这种情况下，将使用可选参数的默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key,val,left=<span class="literal">None</span>,right=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                                       parent=<span class="literal">None</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = val</span><br><span class="line">        self.leftChild = left</span><br><span class="line">        self.rightChild = right</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasRightChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.leftChild == self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRightChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.rightChild == self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRoot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLeaf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.rightChild <span class="keyword">or</span> self.leftChild)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasAnyChildren</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild <span class="keyword">or</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasBothChildren</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild <span class="keyword">and</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceNodeData</span>(<span class="params">self,key,value,lc,rc</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = value</span><br><span class="line">        self.leftChild = lc</span><br><span class="line">        self.rightChild = rc</span><br><span class="line">        <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">            self.leftChild.parent = self</span><br><span class="line">        <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">            self.rightChild.parent = self</span><br></pre></td></tr></table></figure>

<p><em>Listing 2</em></p>
<p>现在我们有了 <code>BinarySearchTree</code> shell 和 <code>TreeNode</code>，现在是时候编写 <code>put</code> 方法，这将允许我们构建二叉搜索树。 <code>put</code> 方法是<code>BinarySearchTree</code> 类的一个方法。此方法将检查树是否已具有根。如果没有根，那么 <code>put</code> 将创建一个新的 <code>TreeNode</code> 并将其做为树的根。如果根节点已经就位，则 put 调用私有递归辅助函数 <code>_put</code> 根据以下算法搜索树：</p>
<ul>
<li>从树的根开始，搜索二叉树，将新键与当前节点中的键进行比较。如果新键小于当前节点，则搜索左子树。如果新键大于当前节点，则搜索右子树。</li>
<li>当没有左（或右）孩子要搜索时，我们在树中找到应该建立新节点的位置。</li>
<li>要向树中添加节点，请创建一个新的 <code>TreeNode</code> 对象，并将对象插入到上一步发现的节点。</li>
</ul>
<p>Listing 3 展示了在树中插入一个新节点的 Python 代码。<code>_put</code> 函数按照上述步骤递归编写。请注意，当一个新的子节点插入到树中时，<code>currentNode</code> 将作为父节点传递给新的树节点。</p>
<p>我们实现插入的一个重要问题是重复的键不能正确处理。当我们的树被实现时，重复键将在具有原始键的节点的右子树中创建具有相同键值的新节点。这样做的结果是，具有新键的节点将永远不会在搜索期间被找到。处理插入重复键的更好方法是将新键相关联的值替换旧值。我们将修复这个bug作为练习。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self,key,val</span>):</span><br><span class="line">    <span class="keyword">if</span> self.root:</span><br><span class="line">        self._put(key,val,self.root)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.root = TreeNode(key,val)</span><br><span class="line">    self.size = self.size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">self,key,val,currentNode</span>):</span><br><span class="line">    <span class="keyword">if</span> key &lt; currentNode.key:</span><br><span class="line">        <span class="keyword">if</span> currentNode.hasLeftChild():</span><br><span class="line">               self._put(key,val,currentNode.leftChild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">               currentNode.leftChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> currentNode.hasRightChild():</span><br><span class="line">               self._put(key,val,currentNode.rightChild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">               currentNode.rightChild = TreeNode(key,val,parent=currentNode)</span><br></pre></td></tr></table></figure>

<p><em>Listing 3</em></p>
<p>当 <code>put</code> 方法定义后，我们可以通过使用 <code>__setitem__</code> 方法调用（参见 Listing 4 ）<code>put</code> 方法来重载赋值的 <code>[]</code> 运算符。这使得我们可以编写像<code>myZipTree[&#39;Plymouth&#39;] = 55446</code> 这样的 Python 语句，就像 Python 字典一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,k,v</span>):</span><br><span class="line">    self.put(k,v)</span><br></pre></td></tr></table></figure>

<p><em>Listing 4</em></p>
<p>Figure 2 展示了用于将新节点插入二叉搜索树的过程。 浅阴影的节点指示在插入过程期间访问的节点。</p>
<p><img src="/assets/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0.figure2.png" alt="6.13.查找树实现.figure2"></p>
<p><em>Figure 2</em></p>
<p>一旦树被构造，下一个任务是实现对给定键的值的检索。<code>get</code> 方法比 <code>put</code> 方法更容易，因为它只是递归地搜索树，直到它到达不匹配的叶节点或找到匹配的键。当找到匹配的键时，返回存储在节点的有效载荷中的值。</p>
<p>Listing 5 展示了 <code>get</code> ，<code>_get</code> 和 <code>__getitem__</code> 的代码。 <code>_get</code> 方法中的搜索代码使用和 <code>_put</code> 相同的逻辑来选择左或右子节点。请注意，<code>_get</code> 方法返回一个 <code>TreeNode</code> ，这允许 <code>_get</code> 用作其他<code>BinarySearchTree</code> 方法的一个灵活的辅助方法，可能需要利用除了有效载荷之外的 <code>TreeNode</code> 的其他数据。</p>
<p>通过实现 <code>__getitem__</code> 方法，我们可以编写一个类似于访问字典的 Python 语句，而实际上我们使用的是二叉搜索树，例如 <code>z = myZipTree [&#39;Fargo&#39;]</code> 。正如你所看到的，所有的 <code>__getitem__</code> 方法都是调用<code>get</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,key</span>):</span><br><span class="line">    <span class="keyword">if</span> self.root:</span><br><span class="line">        res = self._get(key,self.root)</span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">               <span class="keyword">return</span> res.payload</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get</span>(<span class="params">self,key,currentNode</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> currentNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> currentNode.key == key:</span><br><span class="line">        <span class="keyword">return</span> currentNode</span><br><span class="line">    <span class="keyword">elif</span> key &lt; currentNode.key:</span><br><span class="line">        <span class="keyword">return</span> self._get(key,currentNode.leftChild)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self._get(key,currentNode.rightChild)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">    <span class="keyword">return</span> self.get(key)</span><br></pre></td></tr></table></figure>

<p><em>Listing 5</em></p>
<p>使用 <code>get</code> ，我们可以通过为 <code>BinarySearchTree</code> 写一个<code>__contains__</code> 方法来实现 in 操作。 <code>__contains__</code> 方法将简单地调用 <code>get</code> 并在 <code>get</code> 返回值时返回 True，如果返回 None 则返回 False。 <code>__contains__</code> 的代码如Listing 6所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,key</span>):</span><br><span class="line">    <span class="keyword">if</span> self._get(key,self.root):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 6</em></p>
<p>回想一下，<code>__contains__</code> 重载了 <code>in</code> 操作符，允许我们写出如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Northfield&#x27;</span> <span class="keyword">in</span> myZipTree:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;oom ya ya&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>最后，我们将注意力转向二叉搜索树中最具挑战性的方法，删除一个键（参见 Listing 7）。 第一个任务是通过搜索树来找到要删除的节点。 如果树具有多个节点，我们使用 <code>_get</code> 方法搜索以找到需要删除的 <code>TreeNode</code>。 如果树只有一个节点，这意味着我们删除树的根，但是我们仍然必须检查以确保根的键匹配要删除的键。 在任一情况下，如果未找到键，<code>del</code> 操作符将引发错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self,key</span>):</span><br><span class="line">   <span class="keyword">if</span> self.size &gt; <span class="number">1</span>:</span><br><span class="line">      nodeToRemove = self._get(key,self.root)</span><br><span class="line">      <span class="keyword">if</span> nodeToRemove:</span><br><span class="line">          self.remove(nodeToRemove)</span><br><span class="line">          self.size = self.size-<span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Error, key not in tree&#x27;</span>)</span><br><span class="line">   <span class="keyword">elif</span> self.size == <span class="number">1</span> <span class="keyword">and</span> self.root.key == key:</span><br><span class="line">      self.root = <span class="literal">None</span></span><br><span class="line">      self.size = self.size - <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Error, key not in tree&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">    self.delete(key)</span><br></pre></td></tr></table></figure>

<p><em>Listing 7</em></p>
<p>一旦我们找到了我们要删除的键的节点，我们必须考虑三种情况：</p>
<ol>
<li>要删除的节点没有子节点（参见Figure 3）。</li>
<li>要删除的节点只有一个子节点（见Figure 4）。</li>
<li>要删除的节点有两个子节点（见Figure 5）。</li>
</ol>
<p>第一种情况很简单（见 Listing 8）。 如果当前节点没有子节点，我们需要做的是删除节点并删除对父节点中该节点的引用。 此处的代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> currentNode.isLeaf():</span><br><span class="line">    <span class="keyword">if</span> currentNode == currentNode.parent.leftChild:</span><br><span class="line">        currentNode.parent.leftChild = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        currentNode.parent.rightChild = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><em>Listing 8</em></p>
<p><img src="/assets/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0.figure3.png" alt="6.13.查找树实现.figure3"></p>
<p><em>Figure 3</em></p>
<p>第二种情况只是稍微复杂一点（见 Listing 9）。如果一个节点只有一个孩子，那么我们可以简单地促进孩子取代其父。此案例的代码展示在下一个列表中。当你看这个代码，你会看到有六种情况要考虑。由于这些情况相对于左孩子或右孩子对称，我们将仅讨论当前节点具有左孩子的情况。决策如下：</p>
<ol>
<li>如果当前节点是左子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的左子节点引用以指向当前节点的左子节点。</li>
<li>如果当前节点是右子节点，则我们只需要更新左子节点的父引用以指向当前节点的父节点，然后更新父节点的右子节点引用以指向当前节点的左子节点。</li>
<li>如果当前节点没有父级，则它是根。在这种情况下，我们将通过在根上调用<code>replaceNodeData</code> 方法来替换 <code>key</code>，<code>payload</code>，<code>leftChild</code> 和 <code>rightChild</code> 数据。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>: <span class="comment"># this node has one child</span></span><br><span class="line">   <span class="keyword">if</span> currentNode.hasLeftChild():</span><br><span class="line">      <span class="keyword">if</span> currentNode.isLeftChild():</span><br><span class="line">          currentNode.leftChild.parent = currentNode.parent</span><br><span class="line">          currentNode.parent.leftChild = currentNode.leftChild</span><br><span class="line">      <span class="keyword">elif</span> currentNode.isRightChild():</span><br><span class="line">          currentNode.leftChild.parent = currentNode.parent</span><br><span class="line">          currentNode.parent.rightChild = currentNode.leftChild</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          currentNode.replaceNodeData(currentNode.leftChild.key,</span><br><span class="line">                             currentNode.leftChild.payload,</span><br><span class="line">                             currentNode.leftChild.leftChild,</span><br><span class="line">                             currentNode.leftChild.rightChild)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> currentNode.isLeftChild():</span><br><span class="line">          currentNode.rightChild.parent = currentNode.parent</span><br><span class="line">          currentNode.parent.leftChild = currentNode.rightChild</span><br><span class="line">      <span class="keyword">elif</span> currentNode.isRightChild():</span><br><span class="line">          currentNode.rightChild.parent = currentNode.parent</span><br><span class="line">          currentNode.parent.rightChild = currentNode.rightChild</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          currentNode.replaceNodeData(currentNode.rightChild.key,</span><br><span class="line">                             currentNode.rightChild.payload,</span><br><span class="line">                             currentNode.rightChild.leftChild,</span><br><span class="line">                             currentNode.rightChild.rightChild)</span><br></pre></td></tr></table></figure>

<p><em>Listing 9</em></p>
<p><img src="/assets/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0.figure4.png" alt="6.13.查找树实现.figure4"></p>
<p><em>Figure 4</em></p>
<p>第三种情况是最难处理的情况（见Listing 10）。 如果一个节点有两个孩子，那么我们不太可能简单地提升其中一个节点来占据节点的位置。 然而，我们可以在树中搜索可用于替换被调度删除的节点的节点。 我们需要的是一个节点，它将保留现有的左和右子树的二叉搜索树关系。 执行此操作的节点是树中具有次最大键的节点。 我们将这个节点称为后继节点，我们将看一种方法来很快找到后继节点。 继承节点保证没有多于一个孩子，所以我们知道使用已经实现的两种情况删除它。 一旦删除了后继，我们只需将它放在树中，代替要删除的节点。</p>
<p><img src="/assets/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0.figure5.png" alt="6.13.查找树实现.figure5"></p>
<p><em>Figure 5</em></p>
<p>处理第三种情况的代码展示在下一个列表中。 注意，我们使用辅助方法<code>findSuccessor</code> 和 <code>findMin</code> 来找到后继。 要删除后继，我们使用<code>spliceOut</code> 方法。 我们使用 <code>spliceOut</code> 的原因是它直接找到我们想要拼接的节点，并做出正确的更改。 我们可以递归调用删除，但是我们将浪费时间重新搜索关键节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> currentNode.hasBothChildren(): <span class="comment">#interior</span></span><br><span class="line">        succ = currentNode.findSuccessor()</span><br><span class="line">        succ.spliceOut()</span><br><span class="line">        currentNode.key = succ.key</span><br><span class="line">        currentNode.payload = succ.payload</span><br></pre></td></tr></table></figure>

<p><em>Listing 10</em></p>
<p>找到后继的代码如下所示（见 Listing 11），是 <code>TreeNode</code> 类的一个方法。此代码利用二叉搜索树的相同属性，采用中序遍历从最小到最大打印树中的节点。在寻找接班人时，有三种情况需要考虑：</p>
<ol>
<li>如果节点有右子节点，则后继节点是右子树中的最小的键。</li>
<li>如果节点没有右子节点并且是父节点的左子节点，则父节点是后继节点。</li>
<li>如果节点是其父节点的右子节点，并且它本身没有右子节点，则此节点的后继节点是其父节点的后继节点，不包括此节点。</li>
</ol>
<p>第一个条件是对于我们从二叉搜索树中删除节点时唯一重要的条件。但是，<code>findSuccessor</code> 方法具有其他用法，我们将在本章结尾的练习中介绍。</p>
<p>调用 <code>findMin</code> 方法来查找子树中的最小键。你应该说服自己，任何二叉搜索树中的最小值键是树的最左子节点。因此，<code>findMin</code> 方法简单地循环子树的每个节点中的 <code>leftChild</code> 引用，直到它到达没有左子节点的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSuccessor</span>(<span class="params">self</span>):</span><br><span class="line">    succ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">        succ = self.rightChild.findMin()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> self.parent:</span><br><span class="line">               <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                   succ = self.parent</span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   self.parent.rightChild = <span class="literal">None</span></span><br><span class="line">                   succ = self.parent.findSuccessor()</span><br><span class="line">                   self.parent.rightChild = self</span><br><span class="line">    <span class="keyword">return</span> succ</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self</span>):</span><br><span class="line">    current = self</span><br><span class="line">    <span class="keyword">while</span> current.hasLeftChild():</span><br><span class="line">        current = current.leftChild</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spliceOut</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.isLeaf():</span><br><span class="line">        <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">               self.parent.leftChild = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">               self.parent.rightChild = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> self.hasAnyChildren():</span><br><span class="line">        <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">               <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                  self.parent.leftChild = self.leftChild</span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                  self.parent.rightChild = self.leftChild</span><br><span class="line">               self.leftChild.parent = self.parent</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                  self.parent.leftChild = self.rightChild</span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                  self.parent.rightChild = self.rightChild</span><br><span class="line">               self.rightChild.parent = self.parent</span><br></pre></td></tr></table></figure>

<p><em>Listing 11</em></p>
<p>我们需要查看二叉搜索树的最后一个接口方法。假设我们想要按中序遍历树中的所有键。我们肯定用字典做，为什么不是树？你已经知道如何使用中序遍历算法按顺序遍历二叉树。然而，编写迭代器需要更多的工作，因为迭代器在每次调用迭代器时只返回一个节点。</p>
<p>Python 为我们提供了一个非常强大的函数，在创建迭代器时使用。该函数称为<code>yield</code> 。 <code>yield</code> 类似于 <code>return</code>，因为它向调用者返回一个值。然而，yield 采取冻结函数状态的附加步骤，使得下一次调用函数时，它从其早先停止的确切点继续执行。创建可以迭代的对象的函数称为生成函数。</p>
<p>二叉树的 <code>inorder</code> 迭代器的代码展示在下一个列表中。仔细看看这段代码;乍一看，你可能认为代码不是递归的。但是，请记住，<code>__iter__</code> 覆盖 <code>for x in </code>操作，因此它是递归的！因为它是在 <code>TreeNode</code> 实例上递归的，所以<code>__iter__</code> 方法在 <code>TreeNode</code> 类中定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">   <span class="keyword">if</span> self:</span><br><span class="line">      <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">             <span class="keyword">for</span> elem <span class="keyword">in</span> self.leftChild:</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br><span class="line">      <span class="keyword">yield</span> self.key</span><br><span class="line">      <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">             <span class="keyword">for</span> elem <span class="keyword">in</span> self.rightChild:</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br></pre></td></tr></table></figure>

<p>此时，你可能需要下载包含完整版本的 <code>BinarySearchTree</code> 和 <code>TreeNode</code> 类的整个文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key,val,left=<span class="literal">None</span>,right=<span class="literal">None</span>,parent=<span class="literal">None</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = val</span><br><span class="line">        self.leftChild = left</span><br><span class="line">        self.rightChild = right</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasRightChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLeftChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.leftChild == self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRightChild</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.rightChild == self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRoot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLeaf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.rightChild <span class="keyword">or</span> self.leftChild)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasAnyChildren</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild <span class="keyword">or</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasBothChildren</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.rightChild <span class="keyword">and</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceNodeData</span>(<span class="params">self,key,value,lc,rc</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = value</span><br><span class="line">        self.leftChild = lc</span><br><span class="line">        self.rightChild = rc</span><br><span class="line">        <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">            self.leftChild.parent = self</span><br><span class="line">        <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">            self.rightChild.parent = self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self,key,val</span>):</span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            self._put(key,val,self.root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = TreeNode(key,val)</span><br><span class="line">        self.size = self.size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_put</span>(<span class="params">self,key,val,currentNode</span>):</span><br><span class="line">        <span class="keyword">if</span> key &lt; currentNode.key:</span><br><span class="line">            <span class="keyword">if</span> currentNode.hasLeftChild():</span><br><span class="line">                   self._put(key,val,currentNode.leftChild)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                   currentNode.leftChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> currentNode.hasRightChild():</span><br><span class="line">                   self._put(key,val,currentNode.rightChild)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                   currentNode.rightChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,k,v</span>):</span><br><span class="line">       self.put(k,v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,key</span>):</span><br><span class="line">       <span class="keyword">if</span> self.root:</span><br><span class="line">           res = self._get(key,self.root)</span><br><span class="line">           <span class="keyword">if</span> res:</span><br><span class="line">                  <span class="keyword">return</span> res.payload</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get</span>(<span class="params">self,key,currentNode</span>):</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> currentNode:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">       <span class="keyword">elif</span> currentNode.key == key:</span><br><span class="line">           <span class="keyword">return</span> currentNode</span><br><span class="line">       <span class="keyword">elif</span> key &lt; currentNode.key:</span><br><span class="line">           <span class="keyword">return</span> self._get(key,currentNode.leftChild)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> self._get(key,currentNode.rightChild)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">       <span class="keyword">return</span> self.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,key</span>):</span><br><span class="line">       <span class="keyword">if</span> self._get(key,self.root):</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self,key</span>):</span><br><span class="line">      <span class="keyword">if</span> self.size &gt; <span class="number">1</span>:</span><br><span class="line">         nodeToRemove = self._get(key,self.root)</span><br><span class="line">         <span class="keyword">if</span> nodeToRemove:</span><br><span class="line">             self.remove(nodeToRemove)</span><br><span class="line">             self.size = self.size-<span class="number">1</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Error, key not in tree&#x27;</span>)</span><br><span class="line">      <span class="keyword">elif</span> self.size == <span class="number">1</span> <span class="keyword">and</span> self.root.key == key:</span><br><span class="line">         self.root = <span class="literal">None</span></span><br><span class="line">         self.size = self.size - <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Error, key not in tree&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">       self.delete(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spliceOut</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">if</span> self.isLeaf():</span><br><span class="line">           <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                  self.parent.leftChild = <span class="literal">None</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">                  self.parent.rightChild = <span class="literal">None</span></span><br><span class="line">       <span class="keyword">elif</span> self.hasAnyChildren():</span><br><span class="line">           <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">                  <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                     self.parent.leftChild = self.leftChild</span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                     self.parent.rightChild = self.leftChild</span><br><span class="line">                  self.leftChild.parent = self.parent</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                     self.parent.leftChild = self.rightChild</span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                     self.parent.rightChild = self.rightChild</span><br><span class="line">                  self.rightChild.parent = self.parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSuccessor</span>(<span class="params">self</span>):</span><br><span class="line">      succ = <span class="literal">None</span></span><br><span class="line">      <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">          succ = self.rightChild.findMin()</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">if</span> self.parent:</span><br><span class="line">                 <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                     succ = self.parent</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     self.parent.rightChild = <span class="literal">None</span></span><br><span class="line">                     succ = self.parent.findSuccessor()</span><br><span class="line">                     self.parent.rightChild = self</span><br><span class="line">      <span class="keyword">return</span> succ</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self</span>):</span><br><span class="line">      current = self</span><br><span class="line">      <span class="keyword">while</span> current.hasLeftChild():</span><br><span class="line">          current = current.leftChild</span><br><span class="line">      <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,currentNode</span>):</span><br><span class="line">         <span class="keyword">if</span> currentNode.isLeaf(): <span class="comment">#leaf</span></span><br><span class="line">           <span class="keyword">if</span> currentNode == currentNode.parent.leftChild:</span><br><span class="line">               currentNode.parent.leftChild = <span class="literal">None</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               currentNode.parent.rightChild = <span class="literal">None</span></span><br><span class="line">         <span class="keyword">elif</span> currentNode.hasBothChildren(): <span class="comment">#interior</span></span><br><span class="line">           succ = currentNode.findSuccessor()</span><br><span class="line">           succ.spliceOut()</span><br><span class="line">           currentNode.key = succ.key</span><br><span class="line">           currentNode.payload = succ.payload</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span>: <span class="comment"># this node has one child</span></span><br><span class="line">           <span class="keyword">if</span> currentNode.hasLeftChild():</span><br><span class="line">             <span class="keyword">if</span> currentNode.isLeftChild():</span><br><span class="line">                 currentNode.leftChild.parent = currentNode.parent</span><br><span class="line">                 currentNode.parent.leftChild = currentNode.leftChild</span><br><span class="line">             <span class="keyword">elif</span> currentNode.isRightChild():</span><br><span class="line">                 currentNode.leftChild.parent = currentNode.parent</span><br><span class="line">                 currentNode.parent.rightChild = currentNode.leftChild</span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 currentNode.replaceNodeData(currentNode.leftChild.key,</span><br><span class="line">                                    currentNode.leftChild.payload,</span><br><span class="line">                                    currentNode.leftChild.leftChild,</span><br><span class="line">                                    currentNode.leftChild.rightChild)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">if</span> currentNode.isLeftChild():</span><br><span class="line">                 currentNode.rightChild.parent = currentNode.parent</span><br><span class="line">                 currentNode.parent.leftChild = currentNode.rightChild</span><br><span class="line">             <span class="keyword">elif</span> currentNode.isRightChild():</span><br><span class="line">                 currentNode.rightChild.parent = currentNode.parent</span><br><span class="line">                 currentNode.parent.rightChild = currentNode.rightChild</span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 currentNode.replaceNodeData(currentNode.rightChild.key,</span><br><span class="line">                                    currentNode.rightChild.payload,</span><br><span class="line">                                    currentNode.rightChild.leftChild,</span><br><span class="line">                                    currentNode.rightChild.rightChild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mytree = BinarySearchTree()</span><br><span class="line">mytree[<span class="number">3</span>]=<span class="string">&quot;red&quot;</span></span><br><span class="line">mytree[<span class="number">4</span>]=<span class="string">&quot;blue&quot;</span></span><br><span class="line">mytree[<span class="number">6</span>]=<span class="string">&quot;yellow&quot;</span></span><br><span class="line">mytree[<span class="number">2</span>]=<span class="string">&quot;at&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytree[<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(mytree[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.13.%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0/README/" data-id="clxzhp6k100251s8jhvhp8n60" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.12.查找树操作/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.12.%E6%9F%A5%E6%89%BE%E6%A0%91%E6%93%8D%E4%BD%9C/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.904Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-12-查找树操作"><a href="#6-12-查找树操作" class="headerlink" title="6.12.查找树操作"></a>6.12.查找树操作</h2><p>在我们看实现之前，先来看看 map ADT 提供的接口。你会注意到，这个接口与Python 字典非常相似。</p>
<ul>
<li>Map() 创建一个新的空 <code>map</code>。</li>
<li>put(key，val) 向 <code>map</code> 中添加一个新的键值对。如果键已经在 <code>map</code> 中，那么用新值替换旧值。</li>
<li>get(key) 给定一个键，返回存储在 <code>map</code> 中的值，否则为 None。</li>
<li>del 使用 del map[key] 形式的语句从 <code>map</code> 中删除键值对。</li>
<li>len() 返回存储在映射中的键值对的数量。</li>
<li>in 返回 True 如果给定的键在 <code>map</code> 中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.12.%E6%9F%A5%E6%89%BE%E6%A0%91%E6%93%8D%E4%BD%9C/README/" data-id="clxzhp6k200291s8ja7c7388i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python-data-structure-cn/6.树和树的算法/6.11.二叉查找树/README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.11.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/README/" class="article-date">
  <time class="dt-published" datetime="2024-06-29T02:14:12.899Z" itemprop="datePublished">2024-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="6-11-二叉查找树"><a href="#6-11-二叉查找树" class="headerlink" title="6.11.二叉查找树"></a>6.11.二叉查找树</h2><p>我们已经看到了两种不同的方法来获取集合中的键值对。回想一下，这些集合实现了 <code>map</code> 抽象数据类型。我们讨论的 <code>map</code> ADT 的两个实现是在列表和哈希表上的二分搜索。在本节中，我们将研究二叉查找树作为从键映射到值的另一种方法。 在这种情况下，我们对树中项的确切位置不感兴趣，但我们有兴趣使用二叉树结构来提供高效的搜索。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jackfrued.top/2024/06/29/python-data-structure-cn/6.%E6%A0%91%E5%92%8C%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95/6.11.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/README/" data-id="clxzhp6k100241s8j3awp3573" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.9.%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.8.%E6%9E%84%E5%BB%BA%E5%AD%97%E6%A2%AF%E5%9B%BE/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.7.%E5%AD%97%E6%A2%AF%E7%9A%84%E9%97%AE%E9%A2%98/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.6.%E5%AE%9E%E7%8E%B0/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/29/python-data-structure-cn/7.%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95/7.5.%E9%82%BB%E6%8E%A5%E8%A1%A8/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FLITl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>